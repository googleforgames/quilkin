(function() {var type_impls = {
"quilkin":[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Sender%3CT%3E\" class=\"impl\"><a href=\"#impl-Sender%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; Sender&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.new\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">new</a>(init: T) -&gt; Sender&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates the sending-half of the <a href=\"crate::sync::watch\"><code>watch</code></a> channel.</p>\n<p>See documentation of <a href=\"crate::sync::watch\"><code>watch::channel</code></a> for errors when calling this function.\nBeware that attempting to send a value when there are no receivers will\nreturn an error.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>sender = tokio::sync::watch::Sender::new(<span class=\"number\">0u8</span>);\n<span class=\"macro\">assert!</span>(sender.send(<span class=\"number\">3</span>).is_err());\n<span class=\"kw\">let </span>_rec = sender.subscribe();\n<span class=\"macro\">assert!</span>(sender.send(<span class=\"number\">4</span>).is_ok());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">send</a>(&amp;self, value: T) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.77.1/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.1/std/primitive.unit.html\">()</a>, SendError&lt;T&gt;&gt;</h4></section></summary><div class=\"docblock\"><p>Sends a new value via the channel, notifying all receivers.</p>\n<p>This method fails if the channel is closed, which is the case when\nevery receiver has been dropped. It is possible to reopen the channel\nusing the <a href=\"Sender::subscribe\"><code>subscribe</code></a> method. However, when <code>send</code> fails, the value\nisn’t made available for future receivers (but returned with the\n<a href=\"error::SendError\"><code>SendError</code></a>).</p>\n<p>To always make a new value available for future receivers, even if no\nreceiver currently exists, one of the other send methods\n(<a href=\"Sender::send_if_modified\"><code>send_if_modified</code></a>, <a href=\"Sender::send_modify\"><code>send_modify</code></a>, or <a href=\"Sender::send_replace\"><code>send_replace</code></a>) can be\nused instead.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_modify\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">send_modify</a>&lt;F&gt;(&amp;self, modify: F)<div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.1/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.1/std/primitive.reference.html\">&amp;mut T</a>),</div></h4></section></summary><div class=\"docblock\"><p>Modifies the watched value <strong>unconditionally</strong> in-place,\nnotifying all receivers.</p>\n<p>This can be useful for modifying the watched value, without\nhaving to allocate a new instance. Additionally, this\nmethod permits sending values even when there are no receivers.</p>\n<p>Prefer to use the more versatile function [<code>Self::send_if_modified()</code>]\nif the value is only modified conditionally during the mutable borrow\nto prevent unneeded change notifications for unmodified values.</p>\n<h5 id=\"panics\"><a class=\"doc-anchor\" href=\"#panics\">§</a>Panics</h5>\n<p>This function panics when the invocation of the <code>modify</code> closure panics.\nNo receivers are notified when panicking. All changes of the watched\nvalue applied by the closure before panicking will be visible in\nsubsequent calls to <code>borrow</code>.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::watch;\n\n<span class=\"kw\">struct </span>State {\n    counter: usize,\n}\n<span class=\"kw\">let </span>(state_tx, state_rx) = watch::channel(State { counter: <span class=\"number\">0 </span>});\nstate_tx.send_modify(|state| state.counter += <span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(state_rx.borrow().counter, <span class=\"number\">1</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_if_modified\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">send_if_modified</a>&lt;F&gt;(&amp;self, modify: F) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.1/std/primitive.bool.html\">bool</a><div class=\"where\">where\n    F: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.1/core/ops/function/trait.FnOnce.html\" title=\"trait core::ops::function::FnOnce\">FnOnce</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.1/std/primitive.reference.html\">&amp;mut T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.1/std/primitive.bool.html\">bool</a>,</div></h4></section></summary><div class=\"docblock\"><p>Modifies the watched value <strong>conditionally</strong> in-place,\nnotifying all receivers only if modified.</p>\n<p>This can be useful for modifying the watched value, without\nhaving to allocate a new instance. Additionally, this\nmethod permits sending values even when there are no receivers.</p>\n<p>The <code>modify</code> closure must return <code>true</code> if the value has actually\nbeen modified during the mutable borrow. It should only return <code>false</code>\nif the value is guaranteed to be unmodified despite the mutable\nborrow.</p>\n<p>Receivers are only notified if the closure returned <code>true</code>. If the\nclosure has modified the value but returned <code>false</code> this results\nin a <em>silent modification</em>, i.e. the modified value will be visible\nin subsequent calls to <code>borrow</code>, but receivers will not receive\na change notification.</p>\n<p>Returns the result of the closure, i.e. <code>true</code> if the value has\nbeen modified and <code>false</code> otherwise.</p>\n<h5 id=\"panics-1\"><a class=\"doc-anchor\" href=\"#panics-1\">§</a>Panics</h5>\n<p>This function panics when the invocation of the <code>modify</code> closure panics.\nNo receivers are notified when panicking. All changes of the watched\nvalue applied by the closure before panicking will be visible in\nsubsequent calls to <code>borrow</code>.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::watch;\n\n<span class=\"kw\">struct </span>State {\n    counter: usize,\n}\n<span class=\"kw\">let </span>(state_tx, <span class=\"kw-2\">mut </span>state_rx) = watch::channel(State { counter: <span class=\"number\">1 </span>});\n<span class=\"kw\">let </span>inc_counter_if_odd = |state: <span class=\"kw-2\">&amp;mut </span>State| {\n    <span class=\"kw\">if </span>state.counter % <span class=\"number\">2 </span>== <span class=\"number\">1 </span>{\n        state.counter += <span class=\"number\">1</span>;\n        <span class=\"kw\">return </span><span class=\"bool-val\">true</span>;\n    }\n    <span class=\"bool-val\">false\n</span>};\n\n<span class=\"macro\">assert_eq!</span>(state_rx.borrow().counter, <span class=\"number\">1</span>);\n\n<span class=\"macro\">assert!</span>(!state_rx.has_changed().unwrap());\n<span class=\"macro\">assert!</span>(state_tx.send_if_modified(inc_counter_if_odd));\n<span class=\"macro\">assert!</span>(state_rx.has_changed().unwrap());\n<span class=\"macro\">assert_eq!</span>(state_rx.borrow_and_update().counter, <span class=\"number\">2</span>);\n\n<span class=\"macro\">assert!</span>(!state_rx.has_changed().unwrap());\n<span class=\"macro\">assert!</span>(!state_tx.send_if_modified(inc_counter_if_odd));\n<span class=\"macro\">assert!</span>(!state_rx.has_changed().unwrap());\n<span class=\"macro\">assert_eq!</span>(state_rx.borrow_and_update().counter, <span class=\"number\">2</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.send_replace\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">send_replace</a>(&amp;self, value: T) -&gt; T</h4></section></summary><div class=\"docblock\"><p>Sends a new value via the channel, notifying all receivers and returning\nthe previous value in the channel.</p>\n<p>This can be useful for reusing the buffers inside a watched value.\nAdditionally, this method permits sending values even when there are no\nreceivers.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::watch;\n\n<span class=\"kw\">let </span>(tx, _rx) = watch::channel(<span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(tx.send_replace(<span class=\"number\">2</span>), <span class=\"number\">1</span>);\n<span class=\"macro\">assert_eq!</span>(tx.send_replace(<span class=\"number\">3</span>), <span class=\"number\">2</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.borrow\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">borrow</a>(&amp;self) -&gt; Ref&lt;'_, T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a reference to the most recently sent value</p>\n<p>Outstanding borrows hold a read lock on the inner value. This means that\nlong-lived borrows could cause the producer half to block. It is recommended\nto keep the borrow as short-lived as possible. Additionally, if you are\nrunning in an environment that allows <code>!Send</code> futures, you must ensure that\nthe returned <code>Ref</code> type is never held alive across an <code>.await</code> point,\notherwise, it can lead to a deadlock.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::watch;\n\n<span class=\"kw\">let </span>(tx, <span class=\"kw\">_</span>) = watch::channel(<span class=\"string\">\"hello\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>tx.borrow(), <span class=\"string\">\"hello\"</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.is_closed\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">is_closed</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.1/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Checks if the channel has been closed. This happens when all receivers\nhave dropped.</p>\n<h5 id=\"examples-5\"><a class=\"doc-anchor\" href=\"#examples-5\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>(tx, rx) = tokio::sync::watch::channel(());\n<span class=\"macro\">assert!</span>(!tx.is_closed());\n\ndrop(rx);\n<span class=\"macro\">assert!</span>(tx.is_closed());</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.closed\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">closed</a>(&amp;self)</h4></section></summary><div class=\"docblock\"><p>Completes when all receivers have dropped.</p>\n<p>This allows the producer to get notified when interest in the produced\nvalues is canceled and immediately stop doing work.</p>\n<h5 id=\"cancel-safety\"><a class=\"doc-anchor\" href=\"#cancel-safety\">§</a>Cancel safety</h5>\n<p>This method is cancel safe. Once the channel is closed, it stays closed\nforever and all future calls to <code>closed</code> will return immediately.</p>\n<h5 id=\"examples-6\"><a class=\"doc-anchor\" href=\"#examples-6\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::watch;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, rx) = watch::channel(<span class=\"string\">\"hello\"</span>);\n\n    tokio::spawn(<span class=\"kw\">async move </span>{\n        <span class=\"comment\">// use `rx`\n        </span>drop(rx);\n    });\n\n    <span class=\"comment\">// Waits for `rx` to drop\n    </span>tx.closed().<span class=\"kw\">await</span>;\n    <span class=\"macro\">println!</span>(<span class=\"string\">\"the `rx` handles dropped\"</span>)\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.subscribe\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">subscribe</a>(&amp;self) -&gt; Receiver&lt;T&gt;</h4></section></summary><div class=\"docblock\"><p>Creates a new [<code>Receiver</code>] connected to this <code>Sender</code>.</p>\n<p>All messages sent before this call to <code>subscribe</code> are initially marked\nas seen by the new <code>Receiver</code>.</p>\n<p>This method can be called even if there are no other receivers. In this\ncase, the channel is reopened.</p>\n<h5 id=\"examples-7\"><a class=\"doc-anchor\" href=\"#examples-7\">§</a>Examples</h5>\n<p>The new channel will receive messages sent on this <code>Sender</code>.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::watch;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, _rx) = watch::channel(<span class=\"number\">0u64</span>);\n\n    tx.send(<span class=\"number\">5</span>).unwrap();\n\n    <span class=\"kw\">let </span>rx = tx.subscribe();\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">5</span>, <span class=\"kw-2\">*</span>rx.borrow());\n\n    tx.send(<span class=\"number\">10</span>).unwrap();\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">10</span>, <span class=\"kw-2\">*</span>rx.borrow());\n}</code></pre></div>\n<p>The most recent message is considered seen by the channel, so this test\nis guaranteed to pass.</p>\n\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::watch;\n<span class=\"kw\">use </span>tokio::time::Duration;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, _rx) = watch::channel(<span class=\"number\">0u64</span>);\n    tx.send(<span class=\"number\">5</span>).unwrap();\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>rx = tx.subscribe();\n\n    tokio::spawn(<span class=\"kw\">async move </span>{\n        <span class=\"comment\">// by spawning and sleeping, the message is sent after `main`\n        // hits the call to `changed`.\n        </span>tokio::time::sleep(Duration::from_millis(<span class=\"number\">10</span>)).<span class=\"kw\">await</span>;\n        tx.send(<span class=\"number\">100</span>).unwrap();\n    });\n\n    rx.changed().<span class=\"kw\">await</span>.unwrap();\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">100</span>, <span class=\"kw-2\">*</span>rx.borrow());\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.receiver_count\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">receiver_count</a>(&amp;self) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.1/std/primitive.usize.html\">usize</a></h4></section></summary><div class=\"docblock\"><p>Returns the number of receivers that currently exist.</p>\n<h5 id=\"examples-8\"><a class=\"doc-anchor\" href=\"#examples-8\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::watch;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, rx1) = watch::channel(<span class=\"string\">\"hello\"</span>);\n\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">1</span>, tx.receiver_count());\n\n    <span class=\"kw\">let </span><span class=\"kw-2\">mut </span>_rx2 = rx1.clone();\n\n    <span class=\"macro\">assert_eq!</span>(<span class=\"number\">2</span>, tx.receiver_count());\n}</code></pre></div>\n</div></details></div></details>",0,"quilkin::ShutdownTx"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-Sender%3CT%3E\" class=\"impl\"><a href=\"#impl-Debug-for-Sender%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.1/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> for Sender&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.1/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.77.1/core/fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/1.77.1/core/fmt/struct.Formatter.html\" title=\"struct core::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.77.1/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.1/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/1.77.1/core/fmt/struct.Error.html\" title=\"struct core::fmt::Error\">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href=\"https://doc.rust-lang.org/1.77.1/core/fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details>","Debug","quilkin::ShutdownTx"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Drop-for-Sender%3CT%3E\" class=\"impl\"><a href=\"#impl-Drop-for-Sender%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.1/core/ops/drop/trait.Drop.html\" title=\"trait core::ops::drop::Drop\">Drop</a> for Sender&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.drop\" class=\"method trait-impl\"><a href=\"#method.drop\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.77.1/core/ops/drop/trait.Drop.html#tymethod.drop\" class=\"fn\">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a href=\"https://doc.rust-lang.org/1.77.1/core/ops/drop/trait.Drop.html#tymethod.drop\">Read more</a></div></details></div></details>","Drop","quilkin::ShutdownTx"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Clone-for-Sender%3CT%3E\" class=\"impl\"><a href=\"#impl-Clone-for-Sender%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.1/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a> for Sender&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone\" class=\"method trait-impl\"><a href=\"#method.clone\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.77.1/core/clone/trait.Clone.html#tymethod.clone\" class=\"fn\">clone</a>(&amp;self) -&gt; Sender&lt;T&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href=\"https://doc.rust-lang.org/1.77.1/core/clone/trait.Clone.html#tymethod.clone\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.77.1/src/core/clone.rs.html#169\">source</a></span><a href=\"#method.clone_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.77.1/core/clone/trait.Clone.html#method.clone_from\" class=\"fn\">clone_from</a>(&amp;mut self, source: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.1/std/primitive.reference.html\">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href=\"https://doc.rust-lang.org/1.77.1/core/clone/trait.Clone.html#method.clone_from\">Read more</a></div></details></div></details>","Clone","quilkin::ShutdownTx"]]
};if (window.register_type_impls) {window.register_type_impls(type_impls);} else {window.pending_type_impls = type_impls;}})()