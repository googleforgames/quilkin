(function() {var type_impls = {
"quilkin":[["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Receiver%3CT%3E\" class=\"impl\"><a href=\"#impl-Receiver%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; Receiver&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.borrow\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">borrow</a>(&amp;self) -&gt; Ref&lt;'_, T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a reference to the most recently sent value.</p>\n<p>This method does not mark the returned value as seen, so future calls to\n<a href=\"Receiver::changed\"><code>changed</code></a> may return immediately even if you have already seen the\nvalue with a call to <code>borrow</code>.</p>\n<p>Outstanding borrows hold a read lock on the inner value. This means that\nlong-lived borrows could cause the producer half to block. It is recommended\nto keep the borrow as short-lived as possible. Additionally, if you are\nrunning in an environment that allows <code>!Send</code> futures, you must ensure that\nthe returned <code>Ref</code> type is never held alive across an <code>.await</code> point,\notherwise, it can lead to a deadlock.</p>\n<p>The priority policy of the lock is dependent on the underlying lock\nimplementation, and this type does not guarantee that any particular policy\nwill be used. In particular, a producer which is waiting to acquire the lock\nin <code>send</code> might or might not block concurrent calls to <code>borrow</code>, e.g.:</p>\n<details><summary>Potential deadlock example</summary>\n<div class=\"example-wrap\"><pre class=\"language-text\"><code>// Task 1 (on thread A)    |  // Task 2 (on thread B)\nlet _ref1 = rx.borrow();   |\n                           |  // will block\n                           |  let _ = tx.send(());\n// may deadlock            |\nlet _ref2 = rx.borrow();   |\n</code></pre></div></details>\n<p>For more information on when to use this method versus\n<a href=\"Receiver::borrow_and_update\"><code>borrow_and_update</code></a>, see <a href=\"self#borrow_and_update-versus-borrow\">here</a>.</p>\n<h5 id=\"examples\"><a class=\"doc-anchor\" href=\"#examples\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::watch;\n\n<span class=\"kw\">let </span>(<span class=\"kw\">_</span>, rx) = watch::channel(<span class=\"string\">\"hello\"</span>);\n<span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>rx.borrow(), <span class=\"string\">\"hello\"</span>);</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.borrow_and_update\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">borrow_and_update</a>(&amp;mut self) -&gt; Ref&lt;'_, T&gt;</h4></section></summary><div class=\"docblock\"><p>Returns a reference to the most recently sent value and marks that value\nas seen.</p>\n<p>This method marks the current value as seen. Subsequent calls to <a href=\"Receiver::changed\"><code>changed</code></a>\nwill not return immediately until the [<code>Sender</code>] has modified the shared\nvalue again.</p>\n<p>Outstanding borrows hold a read lock on the inner value. This means that\nlong-lived borrows could cause the producer half to block. It is recommended\nto keep the borrow as short-lived as possible. Additionally, if you are\nrunning in an environment that allows <code>!Send</code> futures, you must ensure that\nthe returned <code>Ref</code> type is never held alive across an <code>.await</code> point,\notherwise, it can lead to a deadlock.</p>\n<p>The priority policy of the lock is dependent on the underlying lock\nimplementation, and this type does not guarantee that any particular policy\nwill be used. In particular, a producer which is waiting to acquire the lock\nin <code>send</code> might or might not block concurrent calls to <code>borrow</code>, e.g.:</p>\n<details><summary>Potential deadlock example</summary>\n<div class=\"example-wrap\"><pre class=\"language-text\"><code>// Task 1 (on thread A)                |  // Task 2 (on thread B)\nlet _ref1 = rx1.borrow_and_update();   |\n                                       |  // will block\n                                       |  let _ = tx.send(());\n// may deadlock                        |\nlet _ref2 = rx2.borrow_and_update();   |\n</code></pre></div></details>\n<p>For more information on when to use this method versus <a href=\"Receiver::borrow\"><code>borrow</code></a>, see\n<a href=\"self#borrow_and_update-versus-borrow\">here</a>.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.has_changed\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">has_changed</a>(&amp;self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.77.1/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.1/std/primitive.bool.html\">bool</a>, RecvError&gt;</h4></section></summary><div class=\"docblock\"><p>Checks if this channel contains a message that this receiver has not yet\nseen. The new value is not marked as seen.</p>\n<p>Although this method is called <code>has_changed</code>, it does not check new\nmessages for equality, so this call will return true even if the new\nmessage is equal to the old message.</p>\n<p>Returns an error if the channel has been closed.</p>\n<h5 id=\"examples-1\"><a class=\"doc-anchor\" href=\"#examples-1\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::watch;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = watch::channel(<span class=\"string\">\"hello\"</span>);\n\n    tx.send(<span class=\"string\">\"goodbye\"</span>).unwrap();\n\n    <span class=\"macro\">assert!</span>(rx.has_changed().unwrap());\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>rx.borrow_and_update(), <span class=\"string\">\"goodbye\"</span>);\n\n    <span class=\"comment\">// The value has been marked as seen\n    </span><span class=\"macro\">assert!</span>(!rx.has_changed().unwrap());\n\n    drop(tx);\n    <span class=\"comment\">// The `tx` handle has been dropped\n    </span><span class=\"macro\">assert!</span>(rx.has_changed().is_err());\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.mark_changed\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">mark_changed</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Marks the state as changed.</p>\n<p>After invoking this method <a href=\"Self::has_changed\"><code>has_changed()</code></a>\nreturns <code>true</code> and <a href=\"Self::changed\"><code>changed()</code></a> returns\nimmediately, regardless of whether a new value has been sent.</p>\n<p>This is useful for triggering an initial change notification after\nsubscribing to synchronize new receivers.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.mark_unchanged\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">mark_unchanged</a>(&amp;mut self)</h4></section></summary><div class=\"docblock\"><p>Marks the state as unchanged.</p>\n<p>The current value will be considered seen by the receiver.</p>\n<p>This is useful if you are not interested in the current value\nvisible in the receiver.</p>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.changed\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">changed</a>(&amp;mut self) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.77.1/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.1/std/primitive.unit.html\">()</a>, RecvError&gt;</h4></section></summary><div class=\"docblock\"><p>Waits for a change notification, then marks the newest value as seen.</p>\n<p>If the newest value in the channel has not yet been marked seen when\nthis method is called, the method marks that value seen and returns\nimmediately. If the newest value has already been marked seen, then the\nmethod sleeps until a new message is sent by the <a href=\"struct@Sender\"><code>Sender</code></a> connected to\nthis <code>Receiver</code>, or until the <a href=\"struct@Sender\"><code>Sender</code></a> is dropped.</p>\n<p>This method returns an error if and only if the <a href=\"struct@Sender\"><code>Sender</code></a> is dropped.</p>\n<p>For more information, see\n<a href=\"self#change-notifications\"><em>Change notifications</em></a> in the module-level documentation.</p>\n<h5 id=\"cancel-safety\"><a class=\"doc-anchor\" href=\"#cancel-safety\">§</a>Cancel safety</h5>\n<p>This method is cancel safe. If you use it as the event in a\n<a href=\"crate::select\"><code>tokio::select!</code></a> statement and some other branch\ncompletes first, then it is guaranteed that no values have been marked\nseen by this call to <code>changed</code>.</p>\n<h5 id=\"examples-2\"><a class=\"doc-anchor\" href=\"#examples-2\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::watch;\n\n<span class=\"attr\">#[tokio::main]\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, <span class=\"kw-2\">mut </span>rx) = watch::channel(<span class=\"string\">\"hello\"</span>);\n\n    tokio::spawn(<span class=\"kw\">async move </span>{\n        tx.send(<span class=\"string\">\"goodbye\"</span>).unwrap();\n    });\n\n    <span class=\"macro\">assert!</span>(rx.changed().<span class=\"kw\">await</span>.is_ok());\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>rx.borrow_and_update(), <span class=\"string\">\"goodbye\"</span>);\n\n    <span class=\"comment\">// The `tx` handle has been dropped\n    </span><span class=\"macro\">assert!</span>(rx.changed().<span class=\"kw\">await</span>.is_err());\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.wait_for\" class=\"method\"><h4 class=\"code-header\">pub async fn <a class=\"fn\">wait_for</a>(\n    &amp;mut self,\n    f: impl <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.1/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.1/std/primitive.reference.html\">&amp;T</a>) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.1/std/primitive.bool.html\">bool</a>\n) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.77.1/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;Ref&lt;'_, T&gt;, RecvError&gt;</h4></section></summary><div class=\"docblock\"><p>Waits for a value that satisfies the provided condition.</p>\n<p>This method will call the provided closure whenever something is sent on\nthe channel. Once the closure returns <code>true</code>, this method will return a\nreference to the value that was passed to the closure.</p>\n<p>Before <code>wait_for</code> starts waiting for changes, it will call the closure\non the current value. If the closure returns <code>true</code> when given the\ncurrent value, then <code>wait_for</code> will immediately return a reference to\nthe current value. This is the case even if the current value is already\nconsidered seen.</p>\n<p>The watch channel only keeps track of the most recent value, so if\nseveral messages are sent faster than <code>wait_for</code> is able to call the\nclosure, then it may skip some updates. Whenever the closure is called,\nit will be called with the most recent value.</p>\n<p>When this function returns, the value that was passed to the closure\nwhen it returned <code>true</code> will be considered seen.</p>\n<p>If the channel is closed, then <code>wait_for</code> will return a <code>RecvError</code>.\nOnce this happens, no more messages can ever be sent on the channel.\nWhen an error is returned, it is guaranteed that the closure has been\ncalled on the last value, and that it returned <code>false</code> for that value.\n(If the closure returned <code>true</code>, then the last value would have been\nreturned instead of the error.)</p>\n<p>Like the <code>borrow</code> method, the returned borrow holds a read lock on the\ninner value. This means that long-lived borrows could cause the producer\nhalf to block. It is recommended to keep the borrow as short-lived as\npossible. See the documentation of <code>borrow</code> for more information on\nthis.</p>\n<h5 id=\"examples-3\"><a class=\"doc-anchor\" href=\"#examples-3\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">use </span>tokio::sync::watch;\n\n<span class=\"attr\">#[tokio::main]\n\n</span><span class=\"kw\">async fn </span>main() {\n    <span class=\"kw\">let </span>(tx, _rx) = watch::channel(<span class=\"string\">\"hello\"</span>);\n\n    tx.send(<span class=\"string\">\"goodbye\"</span>).unwrap();\n\n    <span class=\"comment\">// here we subscribe to a second receiver\n    // now in case of using `changed` we would have\n    // to first check the current value and then wait\n    // for changes or else `changed` would hang.\n    </span><span class=\"kw\">let </span><span class=\"kw-2\">mut </span>rx2 = tx.subscribe();\n\n    <span class=\"comment\">// in place of changed we have use `wait_for`\n    // which would automatically check the current value\n    // and wait for changes until the closure returns true.\n    </span><span class=\"macro\">assert!</span>(rx2.wait_for(|val| <span class=\"kw-2\">*</span>val == <span class=\"string\">\"goodbye\"</span>).<span class=\"kw\">await</span>.is_ok());\n    <span class=\"macro\">assert_eq!</span>(<span class=\"kw-2\">*</span>rx2.borrow(), <span class=\"string\">\"goodbye\"</span>);\n}</code></pre></div>\n</div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.same_channel\" class=\"method\"><h4 class=\"code-header\">pub fn <a class=\"fn\">same_channel</a>(&amp;self, other: &amp;Receiver&lt;T&gt;) -&gt; <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.1/std/primitive.bool.html\">bool</a></h4></section></summary><div class=\"docblock\"><p>Returns <code>true</code> if receivers belong to the same channel.</p>\n<h5 id=\"examples-4\"><a class=\"doc-anchor\" href=\"#examples-4\">§</a>Examples</h5>\n<div class=\"example-wrap\"><pre class=\"rust rust-example-rendered\"><code><span class=\"kw\">let </span>(tx, rx) = tokio::sync::watch::channel(<span class=\"bool-val\">true</span>);\n<span class=\"kw\">let </span>rx2 = rx.clone();\n<span class=\"macro\">assert!</span>(rx.same_channel(<span class=\"kw-2\">&amp;</span>rx2));\n\n<span class=\"kw\">let </span>(tx3, rx3) = tokio::sync::watch::channel(<span class=\"bool-val\">true</span>);\n<span class=\"macro\">assert!</span>(!rx3.same_channel(<span class=\"kw-2\">&amp;</span>rx2));</code></pre></div>\n</div></details></div></details>",0,"quilkin::ShutdownRx"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Debug-for-Receiver%3CT%3E\" class=\"impl\"><a href=\"#impl-Debug-for-Receiver%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.1/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a> for Receiver&lt;T&gt;<div class=\"where\">where\n    T: <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.1/core/fmt/trait.Debug.html\" title=\"trait core::fmt::Debug\">Debug</a>,</div></h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.fmt\" class=\"method trait-impl\"><a href=\"#method.fmt\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.77.1/core/fmt/trait.Debug.html#tymethod.fmt\" class=\"fn\">fmt</a>(&amp;self, f: &amp;mut <a class=\"struct\" href=\"https://doc.rust-lang.org/1.77.1/core/fmt/struct.Formatter.html\" title=\"struct core::fmt::Formatter\">Formatter</a>&lt;'_&gt;) -&gt; <a class=\"enum\" href=\"https://doc.rust-lang.org/1.77.1/core/result/enum.Result.html\" title=\"enum core::result::Result\">Result</a>&lt;<a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.1/std/primitive.unit.html\">()</a>, <a class=\"struct\" href=\"https://doc.rust-lang.org/1.77.1/core/fmt/struct.Error.html\" title=\"struct core::fmt::Error\">Error</a>&gt;</h4></section></summary><div class='docblock'>Formats the value using the given formatter. <a href=\"https://doc.rust-lang.org/1.77.1/core/fmt/trait.Debug.html#tymethod.fmt\">Read more</a></div></details></div></details>","Debug","quilkin::ShutdownRx"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Drop-for-Receiver%3CT%3E\" class=\"impl\"><a href=\"#impl-Drop-for-Receiver%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.1/core/ops/drop/trait.Drop.html\" title=\"trait core::ops::drop::Drop\">Drop</a> for Receiver&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.drop\" class=\"method trait-impl\"><a href=\"#method.drop\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.77.1/core/ops/drop/trait.Drop.html#tymethod.drop\" class=\"fn\">drop</a>(&amp;mut self)</h4></section></summary><div class='docblock'>Executes the destructor for this type. <a href=\"https://doc.rust-lang.org/1.77.1/core/ops/drop/trait.Drop.html#tymethod.drop\">Read more</a></div></details></div></details>","Drop","quilkin::ShutdownRx"],["<details class=\"toggle implementors-toggle\" open><summary><section id=\"impl-Clone-for-Receiver%3CT%3E\" class=\"impl\"><a href=\"#impl-Clone-for-Receiver%3CT%3E\" class=\"anchor\">§</a><h3 class=\"code-header\">impl&lt;T&gt; <a class=\"trait\" href=\"https://doc.rust-lang.org/1.77.1/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a> for Receiver&lt;T&gt;</h3></section></summary><div class=\"impl-items\"><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone\" class=\"method trait-impl\"><a href=\"#method.clone\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.77.1/core/clone/trait.Clone.html#tymethod.clone\" class=\"fn\">clone</a>(&amp;self) -&gt; Receiver&lt;T&gt;</h4></section></summary><div class='docblock'>Returns a copy of the value. <a href=\"https://doc.rust-lang.org/1.77.1/core/clone/trait.Clone.html#tymethod.clone\">Read more</a></div></details><details class=\"toggle method-toggle\" open><summary><section id=\"method.clone_from\" class=\"method trait-impl\"><span class=\"rightside\"><span class=\"since\" title=\"Stable since Rust version 1.0.0\">1.0.0</span> · <a class=\"src\" href=\"https://doc.rust-lang.org/1.77.1/src/core/clone.rs.html#169\">source</a></span><a href=\"#method.clone_from\" class=\"anchor\">§</a><h4 class=\"code-header\">fn <a href=\"https://doc.rust-lang.org/1.77.1/core/clone/trait.Clone.html#method.clone_from\" class=\"fn\">clone_from</a>(&amp;mut self, source: <a class=\"primitive\" href=\"https://doc.rust-lang.org/1.77.1/std/primitive.reference.html\">&amp;Self</a>)</h4></section></summary><div class='docblock'>Performs copy-assignment from <code>source</code>. <a href=\"https://doc.rust-lang.org/1.77.1/core/clone/trait.Clone.html#method.clone_from\">Read more</a></div></details></div></details>","Clone","quilkin::ShutdownRx"]]
};if (window.register_type_impls) {window.register_type_impls(type_impls);} else {window.pending_type_impls = type_impls;}})()