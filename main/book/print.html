<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Quilkin Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="installation.html">Installation</a></li><li class="chapter-item expanded affix "><a href="faq.html">FAQ</a></li><li class="chapter-item expanded affix "><li class="part-title">Quickstart Guides</li><li class="chapter-item expanded "><a href="deployment/quickstarts/netcat.html"><strong aria-hidden="true">1.</strong> Netcat</a></li><li class="chapter-item expanded "><a href="deployment/quickstarts/agones-xonotic-sidecar.html"><strong aria-hidden="true">2.</strong> Agones + Xonotic (Sidecar)</a></li><li class="chapter-item expanded "><a href="deployment/quickstarts/agones-xonotic-xds.html"><strong aria-hidden="true">3.</strong> Agones + Xonotic (xDS)</a></li><li class="chapter-item expanded "><a href="deployment/quickstarts/agones-xonotic-relay.html"><strong aria-hidden="true">4.</strong> Agones + Xonotic (Relay)</a></li><li class="chapter-item expanded affix "><li class="part-title">Services</li><li class="chapter-item expanded "><a href="services/proxy.html"><strong aria-hidden="true">5.</strong> Proxy</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="services/proxy/configuration.html"><strong aria-hidden="true">5.1.</strong> Configuration File</a></li><li class="chapter-item expanded "><a href="services/proxy/filters.html"><strong aria-hidden="true">5.2.</strong> Filters</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="services/proxy/filters/capture.html"><strong aria-hidden="true">5.2.1.</strong> Capture</a></li><li class="chapter-item expanded "><a href="services/proxy/filters/compress.html"><strong aria-hidden="true">5.2.2.</strong> Compress</a></li><li class="chapter-item expanded "><a href="services/proxy/filters/concatenate.html"><strong aria-hidden="true">5.2.3.</strong> Concatenate</a></li><li class="chapter-item expanded "><a href="services/proxy/filters/debug.html"><strong aria-hidden="true">5.2.4.</strong> Debug</a></li><li class="chapter-item expanded "><a href="services/proxy/filters/drop.html"><strong aria-hidden="true">5.2.5.</strong> Drop</a></li><li class="chapter-item expanded "><a href="services/proxy/filters/firewall.html"><strong aria-hidden="true">5.2.6.</strong> Firewall</a></li><li class="chapter-item expanded "><a href="services/proxy/filters/load_balancer.html"><strong aria-hidden="true">5.2.7.</strong> Load Balancer</a></li><li class="chapter-item expanded "><a href="services/proxy/filters/local_rate_limit.html"><strong aria-hidden="true">5.2.8.</strong> Local Rate Limit</a></li><li class="chapter-item expanded "><a href="services/proxy/filters/match.html"><strong aria-hidden="true">5.2.9.</strong> Match</a></li><li class="chapter-item expanded "><a href="services/proxy/filters/pass.html"><strong aria-hidden="true">5.2.10.</strong> Pass</a></li><li class="chapter-item expanded "><a href="services/proxy/filters/timestamp.html"><strong aria-hidden="true">5.2.11.</strong> Timestamp</a></li><li class="chapter-item expanded "><a href="services/proxy/filters/token_router.html"><strong aria-hidden="true">5.2.12.</strong> Token Router</a></li><li class="chapter-item expanded "><a href="services/proxy/filters/writing_custom_filters.html"><strong aria-hidden="true">5.2.13.</strong> Writing Custom Filters</a></li></ol></li><li class="chapter-item expanded "><a href="services/proxy/qcmp.html"><strong aria-hidden="true">5.3.</strong> Control Message Protocol</a></li><li class="chapter-item expanded "><a href="services/proxy/metrics.html"><strong aria-hidden="true">5.4.</strong> Metrics</a></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><a href="services/xds.html"><strong aria-hidden="true">6.</strong> Control Plane</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="services/xds/metrics.html"><strong aria-hidden="true">6.1.</strong> Metrics</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Providers</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="services/xds/providers/agones.html"><strong aria-hidden="true">6.2.1.</strong> Agones</a></li><li class="chapter-item expanded "><a href="services/xds/providers/filesystem.html"><strong aria-hidden="true">6.2.2.</strong> Filesystem</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="spacer"></li><li class="chapter-item expanded "><a href="services/relay.html"><strong aria-hidden="true">7.</strong> Relay</a></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">7.1.</strong> Metrics</div></li><li class="chapter-item expanded "><a href="services/agent.html"><strong aria-hidden="true">7.2.</strong> Agents</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">SDKs</li><li class="chapter-item expanded "><a href="sdks/unreal-engine.html"><strong aria-hidden="true">8.</strong> Unreal Engine</a></li><li class="chapter-item expanded affix "><li class="part-title">Deployment</li><li class="chapter-item expanded "><a href="deployment/admin.html"><strong aria-hidden="true">9.</strong> Administration</a></li><li class="chapter-item expanded "><a href="deployment/examples.html"><strong aria-hidden="true">10.</strong> Architecture Examples</a></li><li class="chapter-item expanded affix "><li class="part-title">Third Party</li><li class="chapter-item expanded "><a href="third-party/presentations.html"><strong aria-hidden="true">11.</strong> Videos and Presentations</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Quilkin Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>Quilkin is a UDP proxy, specifically designed for use with multiplayer dedicated game servers.</p>
<h2 id="what-is-quilkin"><a class="header" href="#what-is-quilkin">What is Quilkin?</a></h2>
<p>Quilkin on open source is a non-transparent UDP proxy specifically designed for use with large scale multiplayer
dedicated game servers deployments, to ensure security, access control, telemetry data, metrics and more.</p>
<p>It is designed to be used behind game clients as well as in front of dedicated game servers.</p>
<p>Quilkin's aim is to pull the above functionality out of bespoke, monolithic dedicated game servers and clients, and
provide standard, composable modules that can be reused across a wide set of multiplayer games, so that game
developers can instead focus on their game specific aspects of building a multiplayer game.</p>
<h2 id="why-use-quilkin"><a class="header" href="#why-use-quilkin">Why use Quilkin?</a></h2>
<p>Some of Quilkin's advantages:</p>
<ul>
<li>Lower development and operational costs for securing, monitoring and making reliable multiplayer game servers and
their communications.</li>
<li>Provide entry-point redundancy for your game clients to connect to - making it much harder to take down your game
servers.</li>
<li>Multiple integration patterns, allowing you to choose the level of integration that makes sense for your
architecture.</li>
<li>Remove non-game specific computation out of your game server's processing loop - and save that precious CPU for
your game simulation!</li>
</ul>
<h2 id="major-features"><a class="header" href="#major-features">Major Features</a></h2>
<p>Quilkin incorporates these abilities:</p>
<ul>
<li>Non-transparent proxying of UDP data, the internal state of your game architecture is not visible to bad actors.</li>
<li>Out of the box metrics for UDP packet information.</li>
<li>Composable tools for access control and security.</li>
<li>Able to be utilised as a standalone binary, with no client/server changes required or as a Rust library
depending on how deep an integration you wish for your system.</li>
<li>Integration with Game Server hosting platforms such as <a href="https://agones.dev">Agones</a>.</li>
<li>Can be integrated with C/C++ code bases via FFI.</li>
</ul>
<h2 id="what-next"><a class="header" href="#what-next">What Next?</a></h2>
<p>Quilkin provides a variety of different services depending on your use-case.
The primary service is <a href="./services/proxy.html"><code>proxy</code></a>, which runs a reverse UDP
proxy. To see a basic usage of the command-line interface run through the
<a href="./deployment/quickstarts/netcat.html">netcat with Quilkin quickstart</a>.</p>
<p>For more advanced usage, you might also be interested in:</p>
<ul>
<li>Checking out the <a href="./installation.html">installation guide</a></li>
<li>Having a look at the <a href="https://github.com/googleforgames/quilkin/blob/main/examples">example projects</a> for basic configuration examples.</li>
<li>Checking out the <a href="./deployment/examples.html">example deployment architecture</a>
for deploying quilkin for your game network.</li>
</ul>
<pre><code class="language-shell">$ quilkin --help
The Command-Line Interface for Quilkin

Usage: quilkin [OPTIONS] &lt;COMMAND&gt;

Commands:
  agent                   Runs Quilkin as a relay service that runs a Manager Discovery Service (mDS) for accepting cluster and configuration information from xDS management services, and exposing it as a single merged xDS service for proxy services
  generate-config-schema  Generates JSON schema files for known filters
  manage                  Runs Quilkin as a xDS management server, using `provider` as a configuration source
  qcmp                    
  proxy                   Run Quilkin as a UDP reverse proxy
  relay                   Runs Quilkin as a relay service that runs a Manager Discovery Service (mDS) for accepting cluster and configuration information from xDS management services, and exposing it as a single merged xDS service for proxy services
  help                    Print this message or the help of the given subcommand(s)

Options:
      --no-admin                       Whether to spawn the admin server or not [env: NO_ADMIN=]
  -c, --config &lt;CONFIG&gt;                The path to the configuration file for the Quilkin instance [env: QUILKIN_CONFIG=] [default: quilkin.yaml]
      --admin-address &lt;ADMIN_ADDRESS&gt;  The port to bind for the admin server [env: QUILKIN_ADMIN_ADDRESS=]
  -q, --quiet                          Whether Quilkin will report any results to stdout/stderr [env: QUIET=]
      --log-format &lt;LOG_FORMAT&gt;        [default: auto] [possible values: auto, json, plain, pretty]
  -h, --help                           Print help
  -V, --version                        Print version
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation"><a class="header" href="#installation">Installation</a></h1>
<p>There are variety of automated and manual methods for installing Quilkin onto
your system. For cloud deployments Quilkin provides a <a href="installation.html#oci-image">container image</a>
to make it easily to immediately start using it. You can also install Quilkin on
your local machine through <a href="installation.html#cargo">Cargo</a>.</p>
<h2 id="distributions"><a class="header" href="#distributions">Distributions</a></h2>
<h3 id="oci-image"><a class="header" href="#oci-image"><a href="https://us-docker.pkg.dev/quilkin/release/quilkin">OCI Image</a></a></h3>
<dl>
  <dt><strong>Source / Method</strong></dt>
  <dd>
<pre><code>us-docker.pkg.dev/quilkin/release/quilkin:0.9.0-dev-50d91e4
</code></pre>
  </dd>
  <dt><strong>Notes</strong></dt>
  <dd>Pre-built Quilkin binary with no preset arguments</dd>
</dl>
<h3 id="cargo"><a class="header" href="#cargo"><a href="https://lib.rs/crates/quilkin" data-proofer-ignore>Cargo</a></a></h3>
<dl>
  <dt><strong>Source / Method</strong></dt>
  <dd>
<pre><code>cargo install quilkin
</code></pre>
  </dd>
  <dt><strong>Notes</strong></dt>
  <dd>Compiled from source using cargo</dd>
</dl>
<h3 id="github"><a class="header" href="#github"><a href="https://github.com/googleforgames/quilkin">GitHub</a></a></h3>
<dl>
  <dt><strong>Source / Method</strong></dt>
  <dd>
<p><a href="https://github.com/googleforgames/quilkin/releases">GitHub Releases</a></p>
  </dd>
  <dt><strong>Notes</strong></dt>
  <dd>Pre-built binaries for manual installation</dd>
</dl>
<div style="break-before: page; page-break-before: always;"></div><h1 id="faq"><a class="header" href="#faq">FAQ</a></h1>
<h2 id="just-how-fast-is-quilkin-what-sort-of-performance-can-i-expect"><a class="header" href="#just-how-fast-is-quilkin-what-sort-of-performance-can-i-expect">Just how fast is Quilkin? What sort of performance can I expect?</a></h2>
<p>Our current testing shows that on Quilkin shows that it process packets <em>quite fast</em>!</p>
<p>We won't be publishing performance benchmarks, as performance will always
change depending on the underlying hardware, number of filters, configurations and more.</p>
<p>We highly recommend you run your own load tests on your platform and configuration, matching your production
workload and configuration as close as possible.</p>
<p>Our <a href="https://iperf.fr/">iperf3</a> based performance test in the
<a href="https://github.com/googleforgames/quilkin/tree/main/examples/iperf3">examples' folder</a> is a good starting point.</p>
<p>Since this is still an alpha project, we have plans on investigating further performance improvements in upcoming
releases, both from an optimisation and observability perspective as well.</p>
<h2 id="can-i-integrate-quilkin-with-c-code"><a class="header" href="#can-i-integrate-quilkin-with-c-code">Can I integrate Quilkin with C++ code?</a></h2>
<p>Quilkin is also released as a <a href="https://crates.io/crates/quilkin" data-proofer-ignore>library</a> so it can be
integrated with an external codebase as necessary.</p>
<p>Using Rust code inside a C or C++ project mostly consists of two parts.</p>
<ul>
<li>Creating a C-friendly API in Rust</li>
<li>Embedding your Rust project into an external build system</li>
</ul>
<p>See <a href="https://docs.rust-embedded.org/book/interoperability/rust-with-c.html">A little Rust with your C</a> for more
information.</p>
<p>Over time, we will be expanding documentation on how to integrate with specific engines if running Quilkin as a
separate binary is not an option.</p>
<h2 id="i-would-like-to-run-quilkin-as-a-client-side-proxy-on-a-console-can-i-do-that"><a class="header" href="#i-would-like-to-run-quilkin-as-a-client-side-proxy-on-a-console-can-i-do-that">I would like to run Quilkin as a client side proxy on a console? Can I do that?</a></h2>
<p>This is an ongoing discussion, and since console development is protected by non-disclosure agreements, we can't
comment on this directly.</p>
<p>That being said, we have an <a href="./sdks/unreal-engine.html">Unreal Engine</a> for games
in circumstances where compiling Rust or providing a separate Quilkin binary as
an executable is not an option.</p>
<h2 id="any-reason-you-didnt-contribute-this-intoextend-envoy"><a class="header" href="#any-reason-you-didnt-contribute-this-intoextend-envoy">Any reason you didn't contribute this into/extend Envoy?</a></h2>
<p>This is an excellent question! <a href="https://www.envoyproxy.io/">Envoy</a> is an amazing project, and has set many of the
standards for how <a href="./services/xds.html">proxies are written and orchestrated</a>, and was an inspiration for many of
the decisions made on Quilkin.</p>
<p>However, we decided to build this project separately:</p>
<ul>
<li>Envoy seems primarily focused on web/mobile network workloads (which makes total sense), whereas we wanted
something specialised on gaming UDP communication, so having a leaner, more focused codebase would allow us to move
faster.</li>
<li>We found the Rust and Cargo ecosystem easier to work with than Bazel and C++, and figured our users would as well.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart-quilkin-with-netcat"><a class="header" href="#quickstart-quilkin-with-netcat">Quickstart: Quilkin with netcat</a></h1>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<ul>
<li>A *nix terminal</li>
<li>A binary release of Quilkin from the <a href="https://github.com/googleforgames/quilkin/releases">Github releases page</a> or by running <code>cargo install quilkin</code></li>
<li><a href="https://www.google.com/search?q=ncat">ncat</a></li>
<li><a href="http://netcat.sourceforge.net/">netcat</a></li>
</ul>
<h2 id="1-start-an-udp-echo-service"><a class="header" href="#1-start-an-udp-echo-service">1. Start an udp echo service</a></h2>
<p>So that we have a target for sending UDP packets to, let's use <code>ncat</code> to create a simple UDP echo process.</p>
<p>To do this run:</p>
<pre><code class="language-shell">ncat -e $(which cat) -k -u -l 8080
</code></pre>
<p>This routes all UDP packets that <code>ncat</code> receives to the local <code>cat</code> process, which echoes it back.</p>
<h2 id="2-start-quilkin"><a class="header" href="#2-start-quilkin">2. Start Quilkin</a></h2>
<p>Next let's configure Quilkin in proxy mode, with a static configuration that points at the
UDP echo service we just started.</p>
<pre><code class="language-shell">quilkin proxy --to 127.0.0.1:8080
</code></pre>
<p>This configuration will start Quilkin on the <a href="deployment/quickstarts/../../services/proxy.html">default proxy port</a>, and it will
redirect all incoming UDP traffic to a single endpoint of 127.0.0.1, port 8080.</p>
<p>You should see an output like the following:</p>
<pre><code class="language-shell">{"timestamp":"2023-01-19T10:16:23.399277Z","level":"INFO","fields":{"message":"Starting Quilkin","version":"0.6
.0-dev","commit":"72176a191ffc3a597e3834ee1d0090b30caf81d4"},"target":"quilkin::cli","filename":"src/cli.rs"}
{"timestamp":"2023-01-19T10:16:23.399771Z","level":"INFO","fields":{"message":"Starting admin endpoint","addres
s":"0.0.0.0:8000"},"target":"quilkin::admin","filename":"src/admin.rs"}
{"timestamp":"2023-01-19T10:16:23.400544Z","level":"INFO","fields":{"message":"Starting","port":7777,"proxy_id"
:"7e9fc464-6ccc-41fe-afc4-6c97089de9b8"},"target":"quilkin::proxy","filename":"src/proxy.rs"}
{"timestamp":"2023-01-19T10:16:23.401192Z","level":"INFO","fields":{"message":"Quilkin is ready"},"target":"qui
</code></pre>
<h2 id="3-send-a-packet"><a class="header" href="#3-send-a-packet">3. Send a packet</a></h2>
<p>In (yet üòÉ) another shell, let's use netcat to send an udp packet.</p>
<p>Run the following to connect netcat to Quilkin's receiving port of 7000 via UDP (<code>-u</code>):</p>
<pre><code class="language-shell">nc -u 127.0.0.1 7777
</code></pre>
<p>Type the word "test" and hit enter, you should see it echoed back to you like so:</p>
<pre><code class="language-shell">nc -u 127.0.0.1 7777
test
test
</code></pre>
<p>Feel free to send even more packets, as many as you would like üëç.</p>
<p>Congratulations! You have successfully routed a UDP packet and back again with Quilkin!</p>
<p>What's next?</p>
<ul>
<li>Run through the <a href="deployment/quickstarts/agones-xonotic-sidecar.html">Quilkin with Agones quickstart</a>.</li>
<li>Have a look at some of <a href="https://github.com/googleforgames/quilkin/blob/main/examples">the examples</a> we have.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart-quilkin-with-agones-and-xonotic-sidecar"><a class="header" href="#quickstart-quilkin-with-agones-and-xonotic-sidecar">Quickstart: Quilkin with Agones and Xonotic (Sidecar)</a></h1>
<h2 id="requirements-1"><a class="header" href="#requirements-1">Requirements</a></h2>
<ul>
<li>A terminal with <code>kubectl</code> installed</li>
<li>A local copy of the <a href="https://xonotic.org/">Xonotic</a> client</li>
<li>A running <a href="https://agones.dev/">Agones</a> Kubernetes cluster
<ul>
<li><a href="https://agones.dev/site/docs/installation/">Installation instructions</a></li>
<li>If you aren't familiar with Agones, we recommend working through their
<a href="https://agones.dev/site/docs/getting-started/">Getting Started</a> guides.</li>
</ul>
</li>
</ul>
<h2 id="1-agones-fleet-with-quilkin"><a class="header" href="#1-agones-fleet-with-quilkin">1. Agones Fleet with Quilkin</a></h2>
<p>In this step, we're going to set up a Xonotic dedicated game server, with Quilkin running as a
<a href="deployment/quickstarts/../examples.html#server-proxy-as-a-sidecar">sidecar</a>, which will give us access to all the
<a href="deployment/quickstarts/../../services/proxy/metrics.html">metrics</a> that Quilkin provides.</p>
<pre><code class="language-shell">kubectl apply -f https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic-sidecar/sidecar.yaml
</code></pre>
<p>This applies two resources to your cluster:</p>
<ol>
<li>A Kubernetes <a href="https://kubernetes.io/docs/concepts/configuration/configmap/">ConfigMap</a> with a basic Quilkin
static configuration.</li>
<li>An Agones <a href="https://agones.dev/site/docs/reference/fleet/">Fleet specification</a> with Quilkin running as a sidecar
to Xonotic, such that it can process all the UDP traffic and pass it to the Xonotic dedicated game server.</li>
</ol>
<p>Now you can run <code>kubectl get gameservers</code> until all your Agones <code>GameServers</code> are marked as <code>Ready</code> like so:</p>
<pre><code class="language-shell">$ kubectl get gameservers
NAME                          STATE   ADDRESS         PORT   NODE                                    AGE
xonotic-sidecar-htc2x-84mzm   Ready   34.94.107.201   7533   gke-agones-default-pool-0f7d8adc-7w3c   7m25s
xonotic-sidecar-htc2x-sdp4k   Ready   34.94.107.201   7599   gke-agones-default-pool-0f7d8adc-7w3c   7m25s
</code></pre>
<h2 id="2-play-xonotic"><a class="header" href="#2-play-xonotic">2. Play Xonotic!</a></h2>
<p>Usually with Agones you would
<a href="https://agones.dev/site/docs/getting-started/create-fleet/#4-allocate-a-game-server-from-the-fleet">Allocate</a> a
<code>GameServer</code>, but we'll skip this step for this example.</p>
<p>Choose one of the listed <code>GameServer</code>s from the previous step, and connect to the IP and port of the Xonotic
server via the "Multiplayer &gt; Address" field in the Xonotic client in the format of {IP}:{PORT}.</p>
<p><img src="deployment/quickstarts/xonotic-address-v6.png" alt="xonotic-address.png" /></p>
<p>You should now be playing a game of Xonotic against 4 bots!</p>
<h2 id="3-check-out-the-metrics"><a class="header" href="#3-check-out-the-metrics">3. Check out the metrics</a></h2>
<p>Let's take a look at some metrics that Quilkin outputs.</p>
<p>Grab the name of the GameServer you connected to before, and replace the <code>${gameserver}</code> value below, and run the
command. This will forward the <a href="deployment/quickstarts/../admin.html">admin</a> interface to localhost.</p>
<pre><code class="language-shell">kubectl port-forward ${gameserver} 8000
</code></pre>
<p>Then open a browser to <a href="http://localhost:9091/metrics">http://localhost:8000/metrics</a> to see the
<a href="https://prometheus.io/">Prometheus</a> metrics that Quilkin exports.</p>
<h2 id="5-cleanup"><a class="header" href="#5-cleanup">5. Cleanup</a></h2>
<p>Run the following to delete the Fleet and the accompanying ConfigMap:</p>
<pre><code class="language-shell">kubectl delete -f  https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic-sidecar/sidecar.yaml
</code></pre>
<h2 id="6-agones-fleet-but-with-compression"><a class="header" href="#6-agones-fleet-but-with-compression">6. Agones Fleet, but with Compression</a></h2>
<p>Let's take this one step further and compress the data between the Xonotic client and the server, without having to
change either of them!</p>
<p>Let's create a new Xonotic Fleet on our Agones cluster, but this time configured such that Quilkin will decompress
packets that are incoming.</p>
<p>Run the following:</p>
<pre><code class="language-shell">kubectl apply -f https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic-sidecar/sidecar-compress.yaml
</code></pre>
<p>This will implement the <a href="deployment/quickstarts/../../services/proxy/filters/compress.html">Compress</a> filter in our Quilkin sidecar proxy in our new
Fleet.</p>
<p>Now you can run <code>kubectl get gameservers</code> until all your Agones <code>GameServers</code> are marked as <code>Ready</code> like so:</p>
<pre><code class="language-shell">$ kubectl get gameservers
NAME                                   STATE   ADDRESS         PORT   NODE                                    AGE
xonotic-sidecar-compress-htc2x-84mzm   Ready   34.94.107.201   7534   gke-agones-default-pool-0f7d8adc-7w3c   7m25s
xonotic-sidecar-compress-htc2x-sdp4k   Ready   34.94.107.201   7592   gke-agones-default-pool-0f7d8adc-7w3c   7m25s
</code></pre>
<h2 id="4-play-xonotic-through-quilkin"><a class="header" href="#4-play-xonotic-through-quilkin">4. Play Xonotic, through Quilkin</a></h2>
<p>What we will do in this step, is run Quilkin locally as a client-side proxy to compress the UDP data before it is
sent up to our Xonotic servers that are expecting compressed data.</p>
<p>First, grab a copy of the Quilkin configuration
<a href="https://github.com/googleforgames/quilkin/blob/main/examples/agones-xonotic-sidecar/sidecar-compress.yaml">client-compress.yaml</a>
locally. This has the Compress filter already configured, but we need to fill in the address to connect to.</p>
<blockquote>
<p>Rather than editing a file, this could also be sent through the <a href="deployment/quickstarts/../../services/xds.html">xDS API</a>, but it is easier to
demonstrate this functionality through a static configuration.</p>
</blockquote>
<p>Instead of connecting Xonotic directly, take the IP and port from one of the Agones hosted <code>GameServer</code> records, and
replace the <code>${GAMESERVER_IP}</code> and <code>${GAMESERVER_PORT}</code> values in your copy of <code>client-compress.yaml</code>.</p>
<p>Run this configuration locally as:</p>
<pre><code class="language-shell">quilkin -c ./client-compress.yaml proxy
</code></pre>
<p>Now we can connect to the local client proxy on "127.0.0.1:7777" via the "Multiplayer &gt; Address" field in the
Xonotic client, and Quilkin will take care of compressing the data for you without having to change the game
client!</p>
<p>Congratulations! You are now using Quilkin to manipulate the game client to server connection, without having to
edit either!</p>
<h2 id="7-cleanup"><a class="header" href="#7-cleanup">7. Cleanup</a></h2>
<p>Run the following to delete the Fleet and the accompanying ConfigMap:</p>
<pre><code class="language-shell">kubectl delete -f https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic-sidecar/sidecar-compress.yaml
</code></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<ul>
<li>Have a look at the <a href="https://github.com/googleforgames/quilkin/blob/main/examples">examples</a> folder for configuration and usage examples.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart-quilkin-with-agones-and-xonotic-xds"><a class="header" href="#quickstart-quilkin-with-agones-and-xonotic-xds">Quickstart: Quilkin with Agones and Xonotic (xDS)</a></h1>
<h2 id="requirements-2"><a class="header" href="#requirements-2">Requirements</a></h2>
<ul>
<li>A terminal with <code>kubectl</code> installed</li>
<li>A local copy of the <a href="https://xonotic.org/">Xonotic</a> client</li>
<li>A running <a href="https://agones.dev/">Agones</a> Kubernetes cluster
<ul>
<li><a href="https://agones.dev/site/docs/installation/">Installation instructions</a></li>
<li>If you aren't familiar with Agones, we recommend working through their
<a href="https://agones.dev/site/docs/getting-started/">Getting Started</a> guides.</li>
</ul>
</li>
<li>A local copy of the <a href="https://github.com/googleforgames/quilkin/releases">Quilkin Binary</a>.</li>
</ul>
<h2 id="1-overview"><a class="header" href="#1-overview">1. Overview</a></h2>
<p>In this quickstart, we'll be setting up an example <a href="https://xonotic.org/">Xonotic</a> <a href="https://agones.dev/">Agones</a>
Fleet, that will only be accessible through Quilkin that is hosted within the same cluster, utilising the
<a href="deployment/quickstarts/../../services/proxy/filters/token_router.html">TokenRouter</a> Filter to provide routing and access control to the Allocated <code>GameServer</code> instances.</p>
<p>To do this, we'll take advantage of the Quilkin <a href="deployment/quickstarts/../../services/xds/providers/agones.html">Agones xDS Provider</a> to provide
an out-of-the-box control plane for integration between Agones and <a href="deployment/quickstarts/../../services/xds.html">Quilkin's xDS configuration API</a> with
minimal effort.</p>
<h2 id="2-install-quilkin-agones-xds-provider"><a class="header" href="#2-install-quilkin-agones-xds-provider">2. Install Quilkin Agones xDS Provider</a></h2>
<p>To install Quilkin as an Agones integrated xDS control plane, we can create a deployment of Quilkin running as
<code>quilkin manage agones</code>, with the appropriate permissions.</p>
<p>Run the following:</p>
<pre><code class="language-shell">kubectl apply -f https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic-xds/xds-control-plane.yaml
</code></pre>
<p>This applies several resources to your cluster:</p>
<ol>
<li>A <a href="https://kubernetes.io/docs/concepts/configuration/configmap/">ConfigMap</a> with a <a href="deployment/quickstarts/../../services/proxy/filters/capture.html">Capture</a> and <a href="deployment/quickstarts/../../services/proxy/filters/token_router.html">TokenRouter</a> Filter set up to route packets to Endpoints, to be the base
configuration for all the Quilkin proxies.</li>
<li>Appropriate <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">RBAC</a> permissions for the
<code>quilkin manage agones</code> process to inspect Agones resources.</li>
<li>A matching <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a>  that runs the
<code>quilkin manage process</code> xDS control plane and a
<a href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a> that the Quilkin proxies can connect to,
to get their Filter and Endpoint configuration from.</li>
</ol>
<p>Now we can run <code>kubectl get pods</code> until we see that the Pod for the Deployment is up and running.</p>
<pre><code class="language-shell">$ kubectl get pods
NAME                                    READY   STATUS    RESTARTS   AGE
quilkin-manage-agones-54b787654-9dbvp   1/1     Running   0          76s
</code></pre>
<p>We can now run <code>kubectl get service quilkin-manage-agones</code> and see the
service that is generated in front of the above Deployment for our Quilkin proxies to connect to and receive their
configuration information from.</p>
<pre><code class="language-shell">$ kubectl get service quilkin-manage-agones
NAME                    TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE
quilkin-manage-agones   ClusterIP   10.104.2.72   &lt;none&gt;        80/TCP    1m23s
</code></pre>
<h2 id="3-install-quilkin-proxy-pool"><a class="header" href="#3-install-quilkin-proxy-pool">3. Install Quilkin Proxy Pool</a></h2>
<p>To install the Quilkin Proxy pool which connects to the above xDS provider, we can create a Deployment of Quilkin
proxy instances that point to the aforementioned Service, like so:</p>
<pre><code class="language-shell">kubectl apply -f https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic-xds/proxy-pool.yaml
</code></pre>
<p>This will set up three instances of Quilkin running as <code>quilkin proxy --management-server http://quilkin-manage-agones:80</code>
all connected to the <code>quilkin-manage-agones</code> service.</p>
<p>Now we can run <code>kubectl get pods</code> until we see that the Pods for the proxy Deployment is up and running.</p>
<pre><code class="language-shell">$ kubectl get pods
NAME                                    READY   STATUS    RESTARTS   AGE
quilkin-manage-agones-54b787654-9dbvp   1/1     Running   0          5m7s
quilkin-proxies-78965c446d-dqvjg        1/1     Running   0          6s
quilkin-proxies-78965c446d-fr6zs        1/1     Running   0          6s
quilkin-proxies-78965c446d-m4rr7        1/1     Running   0          6s
</code></pre>
<p>Let's take this one step further, and check the configuration of the proxies that should have come from the <code>quilkin manage agones</code> instance.</p>
<p>In another terminal, run:  <code>kubectl port-forward deployments/quilkin-proxies 8001:8000</code>, to port forward the
<a href="deployment/quickstarts/../admin.html">admin endpoint</a> locally to port 8001, which we can then query.</p>
<p>Go back to your original terminal and run <code>curl -s http://localhost:8001/config</code></p>
<blockquote>
<p>If you have <a href="https://stedolan.github.io/jq/">jq</a> installed, run <code>curl -s http://localhost:8001/config | jq</code> for a
nicely formatted JSON output.</p>
</blockquote>
<pre><code class="language-shell">$ curl -s http://localhost:8001/config | jq
{
  "clusters": [
    {
      "endpoints": [],
      "locality": null
    }
  ],
  "filters": [
    {
      "name": "quilkin.filters.capture.v1alpha1.Capture",
      "label": null,
      "config": {
        "metadataKey": "quilkin.dev/capture",
        "suffix": {
          "size": 3,
          "remove": true
        }
      }
    },
    {
      "name": "quilkin.filters.token_router.v1alpha1.TokenRouter",
      "label": null,
      "config": null
    }
  ],
  "id": "quilkin-proxies-7d9bbbccdf-9vd59",
  "version": "v1alpha1"
}
</code></pre>
<p>This shows us the current configuration of the proxies coming from the xDS server created via <code>quilkin manage agones</code>. The most interesting part that we see here, is that we have a matching set of
<a href="deployment/quickstarts/../../services/proxy/filters.html">Filters</a> that are found in the <code>ConfigMap</code> in the
<a href="https://github.com/googleforgames/quilkin/blob/main/examples/agones-xonotic-xds/xds-control-plane.yaml">xds-control-plane.yaml</a>
we installed earlier.</p>
<h2 id="4-create-the-agones-fleet"><a class="header" href="#4-create-the-agones-fleet">4. Create the Agones Fleet</a></h2>
<p>Now we will create an <a href="https://agones.dev/site/docs/reference/fleet/">Agones Fleet</a> to spin up all our Xonotic
game servers.</p>
<p>Thankfully, Agones Fleets require no specific configuration to work with Quilkin proxies, so this yaml is a
<a href="https://github.com/googleforgames/quilkin/blob/main/examples/agones-xonotic-xds/fleet.yaml">standard Agones Fleet configuration</a></p>
<pre><code class="language-shell">kubectl apply -f https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic-xds/fleet.yaml
</code></pre>
<p>Run <code>kubectl get gameservers</code> until all the <code>GameServer</code> records show that they are <code>Ready</code> and able to take players.</p>
<pre><code class="language-shell">$ kubectl get gameservers
NAME                  STATE   ADDRESS         PORT   NODE                               AGE
xonotic-d7rfx-55j7q   Ready   34.168.170.51   7226   gke-agones-default-534a3f8d-ifpc   34s
xonotic-d7rfx-nx7xr   Ready   34.168.170.51   7984   gke-agones-default-534a3f8d-ifpc   34s
xonotic-d7rfx-sn5d6   Ready   34.168.170.51   7036   gke-agones-default-534a3f8d-ifpc   34s
</code></pre>
<h2 id="5-allocate-a-gameserver"><a class="header" href="#5-allocate-a-gameserver">5. Allocate a <code>GameServer</code></a></h2>
<p>To let the Quilkin xDS provider know what token will route to which <code>GameServer</code> we need to apply the
<code>quilkin.dev/tokens</code> annotation to an allocated <code>GameServer</code>, with the token content as its value.</p>
<blockquote>
<p>This token would normally get generated by some kind of  player authentication service and passed to the client
via the matchmaking service - but for demonstrative purposes, we've hardcoded it into the example
<code>GameServerAllocation</code>.</p>
</blockquote>
<p>Since you can add annotations to <code>GameServers</code> at
<a href="https://agones.dev/site/docs/reference/gameserverallocation/">allocation time</a>, we can both allocate a <code>GameServer</code>
and apply the annotation at the same time!</p>
<pre><code class="language-shell">kubectl create -f https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic-xds/gameserverallocation.yaml
</code></pre>
<p>If we check our <code>GameServers</code> now, we should see that one of them has moved to the <code>Allocated</code> state, marking it as
having players playing on it, and therefore it is protected by Agones until the game session ends.</p>
<pre><code class="language-shell">$ kubectl get gs
NAME                  STATE       ADDRESS         PORT   NODE                               AGE
xonotic-d7rfx-55j7q   Allocated   34.168.170.51   7226   gke-agones-default-534a3f8d-ifpc   23m
xonotic-d7rfx-nx7xr   Ready       34.168.170.51   7984   gke-agones-default-534a3f8d-ifpc   23m
xonotic-d7rfx-sn5d6   Ready       34.168.170.51   7036   gke-agones-default-534a3f8d-ifpc   23m
</code></pre>
<blockquote>
<p>Don't do this more than once, as then multiple allocated <code>GameServers</code> will have the same routing token!</p>
</blockquote>
<p>If we <code>kubectl describe gameserver &lt;allocated-gameserver&gt;</code> and have a look at the annotations section, we
should see something similar to this:</p>
<pre><code class="language-shell">$ kubectl describe gameserver xonotic-d7rfx-55j7q
Name:         xonotic-d7rfx-55j7q
Namespace:    default
Labels:       agones.dev/fleet=xonotic
              agones.dev/gameserverset=xonotic-h5cfn
Annotations:  agones.dev/last-allocated: 2022-12-19T22:59:22.099818298Z
              agones.dev/ready-container-id: containerd://7b3d9e9dbda6f2e0381df7669f6117bf3e54171469cfacbce2670605a61ce4b8
              agones.dev/sdk-version: 1.40.0
              quilkin.dev/tokens: NDU2
API Version:  agones.dev/v1
Kind:         GameServer
...
</code></pre>
<p>Where we can see that there is now an annotation of <code>quilkin.dev/tokens</code> with the base64 encoded version of <code>456</code> as
our authentication and routing token ("NDU2").</p>
<blockquote>
<p>You should use something more cryptographically random than <code>456</code> in your application.</p>
</blockquote>
<p>Let's run <code>curl -s http://localhost:8001/config</code> again, so we can see what has changed!</p>
<pre><code class="language-shell">‚ùØ curl -s http://localhost:8001/config | jq
{
  "clusters": [
    {
      "endpoints": [
        {
          "address": "34.168.170.51:7226",
          "metadata": {
            "quilkin.dev": {
              "tokens": [
                "NDU2"
              ]
            },
            "name": "xonotic-8ns7b-2lk5d"
          }
        }
      ],
      "locality": null
    }
  ],
  "filters": [
    {
      "name": "quilkin.filters.capture.v1alpha1.Capture",
      "label": null,
      "config": {
        "metadataKey": "quilkin.dev/capture",
        "suffix": {
          "size": 3,
          "remove": true
        }
      }
    },
    {
      "name": "quilkin.filters.token_router.v1alpha1.TokenRouter",
      "label": null,
      "config": null
    }
  ],
  "id": "quilkin-proxies-7d9bbbccdf-9vd59",
  "version": "v1alpha1"
}
</code></pre>
<p>Looking under <code>clusters</code> &gt; <code>endpoints</code> we can see an address and token that matches up with the
<code>GameServer</code> record we created above!</p>
<p>The xDS process saw that allocated <code>GameServer</code>, turned it into a Quilkin <code>Endpoint</code> and applied the set the routing
token appropriately -- without you having to write a line of xDS compliant code!</p>
<h2 id="connecting-client-side"><a class="header" href="#connecting-client-side">Connecting Client Side</a></h2>
<p>Instead of connecting to Xonotic or an Agones <code>GameServer</code> directly, we'll want to grab the IP and exposed port of
the <code>Service</code> that fronts all our Quilkin proxies and connect to that instead -- but we'll have to append our
routing token <code>456</code> from before, to ensure our traffic gets routed to the correct Xonotic <code>GameServer</code> address.</p>
<p>Run <code>kubectl get service quilkin-proxies</code> to get the <code>EXTERNAL-IP</code> of the Service you created.</p>
<pre><code class="language-shell">$ kubectl get service quilkin-proxies
NAME              TYPE           CLUSTER-IP    EXTERNAL-IP     PORT(S)          AGE
quilkin-proxies   LoadBalancer   10.109.0.12   35.246.94.14    7777:30174/UDP   3h22m
</code></pre>
<p>We have a <a href="https://github.com/googleforgames/quilkin/blob/main/examples/agones-xonotic-xds/client-token.yaml">Quilkin config yaml</a>
file all ready for you, that is configured to append the routing token <code>456</code> to each
packet that passes through it, via the power of a
<a href="deployment/quickstarts/../../services/proxy/filters/concatenate.html">Concatenate</a> Filter.</p>
<p>Download <code>client-token.yaml</code> locally, so you can edit it:</p>
<pre><code class="language-shell">curl https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic-xds/client-token.yaml --output client-token.yaml
</code></pre>
<p>We then take the EXTERNAL-IP and port from the <code>quilkin-proxies</code> service, and replace the<code>${LOADBALANCER_IP}</code>
with it in <code>client-token.yaml</code>.</p>
<p>Run this edited configuration locally with your quilkin binary as <code>quilkin -c ./client-token.yaml proxy</code>:</p>
<pre><code class="language-shell">$ ./quilkin --config ./client-token.yaml proxy
2023-10-04T20:09:07.320780Z  INFO quilkin::cli: src/cli.rs: Starting Quilkin version="0.7.0-dev" commit="d42db7e14c2e0e758e9a6eb655ccf4184941066c"
2023-10-04T20:09:07.321711Z  INFO quilkin::admin: src/admin.rs: Starting admin endpoint address=[::]:8000
2023-10-04T20:09:07.322089Z  INFO quilkin::cli::proxy: src/cli/proxy.rs: Starting port=7777 proxy_id="markmandel45"
2023-10-04T20:09:07.322576Z  INFO quilkin::cli::proxy: src/cli/proxy.rs: Quilkin is ready
2023-10-04T20:09:07.322692Z  INFO qcmp_task{v4_addr=0.0.0.0:7600 v6_addr=[::]:7600}: quilkin::protocol: src/protocol.rs: awaiting qcmp packets v4_addr=0.0.0.0:7600 v6_addr=[::]:7600
</code></pre>
<p>Now connect to the local client proxy on "[::1]:7777" via the "Multiplayer &gt; Address" field in the
Xonotic client, and Quilkin will take care of appending the routing token to all your UDP packets, which the Quilkin
proxies will route to the Allocated GameServer, and you can play a gamee!</p>
<p><img src="deployment/quickstarts/xonotic-address-v6.png" alt="xonotic-address-v6.png" /></p>
<p>...And you didn't have to change the client or the dedicated game server ü§∏</p>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What's Next?</a></h2>
<ul>
<li>Check out the variety of <a href="deployment/quickstarts/../../services/proxy/filters.html">Filters</a> that are possible with Quilkin.</li>
<li>Read into the <a href="deployment/quickstarts/../../services/xds.html">xDS Management API</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart-quilkin-with-agones-and-xonotic-relay"><a class="header" href="#quickstart-quilkin-with-agones-and-xonotic-relay">Quickstart: Quilkin with Agones and Xonotic (Relay)</a></h1>
<h2 id="requirements-3"><a class="header" href="#requirements-3">Requirements</a></h2>
<ul>
<li>A terminal with <code>kubectl</code> installed</li>
<li>A local copy of the <a href="https://xonotic.org/">Xonotic</a> client</li>
<li>A running <a href="https://agones.dev/">Agones</a> Kubernetes cluster
<ul>
<li><a href="https://agones.dev/site/docs/installation/">Installation instructions</a></li>
<li>If you aren't familiar with Agones, we recommend working through their
<a href="https://agones.dev/site/docs/getting-started/">Getting Started</a> guides.</li>
</ul>
</li>
<li>A local copy of the <a href="https://github.com/googleforgames/quilkin/releases">Quilkin Binary</a>.</li>
</ul>
<h2 id="1-overview-1"><a class="header" href="#1-overview-1">1. Overview</a></h2>
<p>In this quickstart, we'll be setting up an example multi-cluster
<a href="https://xonotic.org/">Xonotic</a> <a href="https://agones.dev/">Agones</a> Fleet, that will
only be accessible through Quilkin, via utilising the <a href="deployment/quickstarts/../../services/proxy/filters/token_router.html">TokenRouter</a> Filter to
provide routing and access control to the Allocated <code>GameServer</code> instances.</p>
<p>To do this, we'll take advantage of the Quilkin <a href="deployment/quickstarts/../../services/relay.html">Relay</a> to provide
an out-of-the-box multi-cluster xDS control plane, and the <a href="deployment/quickstarts/../../services/agent.html">Agones Agent</a>
to send information from the cluster(s) to the relay, which can be used as a
management server for each of the Quilkin <a href="deployment/quickstarts/../../services/proxy.html">Proxy</a> instances.</p>
<blockquote>
<p>While the application of <code>quilkin relay</code> is to ultimately provide a solution where multiple clusters feed
configuration information into a single relay endpoint via a <code>quilkin agent</code>, in this example we'll
use a single cluster for demonstrative purposes.</p>
</blockquote>
<h2 id="2-install-quilkin-relay-and-agones-agent"><a class="header" href="#2-install-quilkin-relay-and-agones-agent">2. Install Quilkin Relay and Agones Agent</a></h2>
<p>To install Quilkin as an Agones integrated relay control plane, we can create a deployment of Quilkin running as
<code>quilkin relay</code> with a corresponding Agones agent, <code>quilkin agent agones</code>, with the appropriate permissions.</p>
<p>Run the following:</p>
<pre><code class="language-shell">kubectl apply -f https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic-relay/relay-control-plane.yaml
</code></pre>
<p>This applies several resources to your cluster:</p>
<ol>
<li>A <a href="https://kubernetes.io/docs/concepts/configuration/configmap/">ConfigMap</a> with a <a href="deployment/quickstarts/../../services/proxy/filters/capture.html">Capture</a> and <a href="deployment/quickstarts/../../services/proxy/filters/token_router.html">TokenRouter</a> Filter set up to route packets to Endpoints, to be the base
configuration for all the Quilkin proxies.</li>
<li>Appropriate <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">RBAC</a> permissions for the
<code>quilkin agent agones</code> process to inspect Agones resources.</li>
<li>A <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a>  that runs the
<code>quilkin relay</code> process, a matching Deployment for the <code>quilkin agent</code> process and a
<a href="https://kubernetes.io/docs/concepts/services-networking/service/">Service</a> that the Quilkin agents can send configuration information to, and the Proxies can connect to,
to get their Filter and Endpoint configuration from.</li>
</ol>
<p>Now we can run <code>kubectl get pods</code> until we see that the Pod for the Deployment is up and running.</p>
<pre><code class="language-shell">$ kubectl get pods
NAME                                    READY   STATUS    RESTARTS   AGE
quilkin-agones-agent-9dd6699bd-qh7cq    1/1     Running   0          6s
quilkin-relay-agones-55fbd69f5d-cdh9k   1/1     Running   0          6s
</code></pre>
<p>We can now run <code>kubectl get service quilkin-relay-agones</code> and see the
service that is generated in front of the above Quilkin Relay Deployment for our Quilkin Proxies to connect to and
receive their configuration information from.</p>
<pre><code class="language-shell">$ kubectl get service quilkin-relay-agones
NAME                   TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)             AGE
quilkin-relay-agones   ClusterIP   10.103.243.246   &lt;none&gt;        7800/TCP,7900/TCP   57s
</code></pre>
<h2 id="3-install-quilkin-proxy-pool-1"><a class="header" href="#3-install-quilkin-proxy-pool-1">3. Install Quilkin Proxy Pool</a></h2>
<p>To install the Quilkin Proxy pool which connects to the above Relay xDS provider, we can create a Deployment of Quilkin
proxy instances that point to the aforementioned Service, like so:</p>
<pre><code class="language-shell">kubectl apply -f https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic-relay/proxy-pool.yaml
</code></pre>
<p>This will set up three instances of Quilkin running as <code>quilkin proxy --management-server http://quilkin-relay-agones:7900</code> all of which are connected to the <code>quilkin-relay-agones</code> service.</p>
<p>Now we can run <code>kubectl get pods</code> until we see that the Pods for the proxy Deployment is up and running.</p>
<pre><code class="language-shell">$ kubectl get pods                  
NAME                                    READY   STATUS    RESTARTS   AGE
quilkin-agones-agent-9dd6699bd-5brzf    1/1     Running   0          18s
quilkin-proxies-7d9bbbccdf-5mz4l        1/1     Running   0          7s
quilkin-proxies-7d9bbbccdf-9vd59        1/1     Running   0          7s
quilkin-proxies-7d9bbbccdf-vwn2f        1/1     Running   0          7s
quilkin-relay-agones-55fbd69f5d-k2n7b   1/1     Running   0          18s
</code></pre>
<p>Let's take this one step further, and check the configuration of the proxies that should have come from the <code>quilkin  agent agones</code> instance and passed through the <code>quilkin relay instance</code> into each of the proxies.</p>
<p>In another terminal, run:  <code>kubectl port-forward deployments/quilkin-proxies 8001:8000</code>, to port forward the
<a href="deployment/quickstarts/../admin.html">admin endpoint</a> locally to port 8001, which we can then query.</p>
<p>Go back to your original terminal and run <code>curl -s http://localhost:8001/config</code></p>
<blockquote>
<p>If you have <a href="https://stedolan.github.io/jq/">jq</a> installed, run <code>curl -s http://localhost:8001/config | jq</code> for a
nicely formatted JSON output.</p>
</blockquote>
<pre><code class="language-shell">$ curl -s http://localhost:8001/config | jq
{
  "clusters": [
    {
      "endpoints": [],
      "locality": null
    }
  ],
  "filters": [
    {
      "name": "quilkin.filters.capture.v1alpha1.Capture",
      "label": null,
      "config": {
        "metadataKey": "quilkin.dev/capture",
        "suffix": {
          "size": 3,
          "remove": true
        }
      }
    },
    {
      "name": "quilkin.filters.token_router.v1alpha1.TokenRouter",
      "label": null,
      "config": null
    }
  ],
  "id": "quilkin-proxies-7d9bbbccdf-9vd59",
  "version": "v1alpha1"
}
</code></pre>
<p>This shows us the current configuration of the proxies coming from the xDS server created via <code>quilkin agent  agones</code>. The most interesting part that we see here, is that we have a matching set of
<a href="deployment/quickstarts/../../services/proxy/filters.html">Filters</a> that are found in the <code>ConfigMap</code> in the
<a href="https://github.com/googleforgames/quilkin/blob/main/examples/agones-xonotic-relay/relay-control-plane.yaml">relay-control-plane.yaml</a>
we installed earlier.</p>
<h2 id="4-create-the-agones-fleet-1"><a class="header" href="#4-create-the-agones-fleet-1">4. Create the Agones Fleet</a></h2>
<p>Now we will create an <a href="https://agones.dev/site/docs/reference/fleet/">Agones Fleet</a> to spin up all our Xonotic
game servers.</p>
<p>Thankfully, Agones Fleets require no specific configuration to work with Quilkin proxies, so this yaml is a
<a href="https://github.com/googleforgames/quilkin/blob/main/examples/agones-xonotic-relay/fleet.yaml">standard Agones Fleet configuration</a></p>
<pre><code class="language-shell">kubectl apply -f https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic-relay/fleet.yaml
</code></pre>
<p>Run <code>kubectl get gameservers</code> until all the <code>GameServer</code> records show that they are <code>Ready</code> and able to take players.</p>
<pre><code class="language-shell">$ kubectl get gs
NAME                  STATE       ADDRESS         PORT   NODE                               AGE
xonotic-8ns7b-2lk5d   Ready       39.168.219.72   7015   gke-agones-default-ad8cd7e5-3b12   1m
xonotic-8ns7b-hrc8j   Ready       39.168.219.72   7298   gke-agones-default-ad8cd7e5-3b12   1m
xonotic-8ns7b-mldg6   Ready       39.168.219.72   7558   gke-agones-default-ad8cd7e5-3b12   1m
</code></pre>
<h2 id="5-allocate-a-gameserver-1"><a class="header" href="#5-allocate-a-gameserver-1">5. Allocate a <code>GameServer</code></a></h2>
<p>To let the Quilkin Agones Agent know what token will route to which <code>GameServer</code> we need to apply the
<code>quilkin.dev/tokens</code> annotation to an allocated <code>GameServer</code>, with the token content as its value.</p>
<blockquote>
<p>This token would normally get generated by some kind of  player authentication service and passed to the client
via the matchmaking service - but for demonstrative purposes, we've hardcoded it into the example
<code>GameServerAllocation</code>.</p>
</blockquote>
<p>Since you can add annotations to <code>GameServers</code> at
<a href="https://agones.dev/site/docs/reference/gameserverallocation/">allocation time</a>, we can both allocate a <code>GameServer</code>
and apply the annotation at the same time!</p>
<pre><code class="language-shell">kubectl create -f https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic-relay/gameserverallocation.yaml
</code></pre>
<p>If we check our <code>GameServers</code> now, we should see that one of them has moved to the <code>Allocated</code> state, marking it as
having players playing on it, and therefore it is protected by Agones until the game session ends.</p>
<pre><code class="language-shell">$ kubectl get gs
NAME                  STATE       ADDRESS         PORT   NODE                               AGE
xonotic-8ns7b-2lk5d   Allocated   39.168.219.72   7015   gke-agones-default-ad8cd7e5-3b12   17m
xonotic-8ns7b-hrc8j   Ready       39.168.219.72   7298   gke-agones-default-ad8cd7e5-3b12   17m
xonotic-8ns7b-mldg6   Ready       39.168.219.72   7558   gke-agones-default-ad8cd7e5-3b12   17m
</code></pre>
<blockquote>
<p>Don't do this more than once, as then multiple allocated <code>GameServers</code> will have the same routing token!</p>
</blockquote>
<p>If we <code>kubectl describe gameserver &lt;allocated-gameserver&gt;</code> and have a look at the annotations section, we
should see something similar to this:</p>
<pre><code class="language-shell">‚ùØ kubectl describe gs xonotic-8ns7b-2lk5d
Name:         xonotic-8ns7b-2lk5d
Namespace:    default
Labels:       agones.dev/fleet=xonotic
              agones.dev/gameserverset=xonotic-8ns7b
Annotations:  agones.dev/last-allocated: 2023-10-04T19:47:04.047026419Z
              agones.dev/ready-container-id: containerd://b39d30965becdbc40336fd9aa642fe776421553615f642dd599e1b0d88c505b6
              agones.dev/sdk-version: 1.40.0
              quilkin.dev/tokens: NDU2
API Version:  agones.dev/v1
Kind:         GameServer
...
</code></pre>
<p>Where we can see that there is now an annotation of <code>quilkin.dev/tokens</code> with the base64 encoded version of <code>456</code> as
our authentication and routing token ("NDU2").</p>
<blockquote>
<p>You should use something more cryptographically random than <code>456</code> in your application.</p>
</blockquote>
<p>Let's run <code>curl -s http://localhost:8001/config</code> again, so we can see what has changed!</p>
<pre><code class="language-shell">‚ùØ curl -s http://localhost:8001/config | jq
{
  "clusters": [
    {
      "endpoints": [
        {
          "address": "39.168.219.72:7015",
          "metadata": {
            "quilkin.dev": {
              "tokens": [
                "NDU2"
              ]
            },
            "name": "xonotic-8ns7b-2lk5d"
          }
        }
      ],
      "locality": null
    }
  ],
  "filters": [
    {
      "name": "quilkin.filters.capture.v1alpha1.Capture",
      "label": null,
      "config": {
        "metadataKey": "quilkin.dev/capture",
        "suffix": {
          "size": 3,
          "remove": true
        }
      }
    },
    {
      "name": "quilkin.filters.token_router.v1alpha1.TokenRouter",
      "label": null,
      "config": null
    }
  ],
  "id": "quilkin-proxies-7d9bbbccdf-9vd59",
  "version": "v1alpha1"
}
</code></pre>
<p>Looking under <code>clusters</code> &gt; <code>endpoints</code> we can see an address and token that matches up with the
<code>GameServer</code> record we created above!</p>
<p>The Agones agent process saw that allocated <code>GameServer</code>, turned it into a Quilkin <code>Endpoint</code> and applied the set
routing token appropriately -- without you having to write a line of xDS compliant code!</p>
<h2 id="connecting-client-side-1"><a class="header" href="#connecting-client-side-1">Connecting Client Side</a></h2>
<p>Instead of connecting to Xonotic or an Agones <code>GameServer</code> directly, we'll want to grab the IP and exposed port of
the <code>Service</code> that fronts all our Quilkin proxies and connect to that instead -- but we'll have to append our
routing token <code>456</code> from before, to ensure our traffic gets routed to the correct Xonotic <code>GameServer</code> address.</p>
<p>Run <code>kubectl get service quilkin-proxies</code> to get the <code>EXTERNAL-IP</code> of the Service you created.</p>
<pre><code class="language-shell">$ kubectl get service quilkin-proxies
NAME              TYPE           CLUSTER-IP    EXTERNAL-IP     PORT(S)          AGE
quilkin-proxies   LoadBalancer   10.109.0.12   35.246.94.14    7777:30174/UDP   3h22m
</code></pre>
<p>We have a <a href="https://github.com/googleforgames/quilkin/blob/main/examples/agones-xonotic-relay/client-token.yaml">Quilkin config yaml</a>
file all ready for you, that is configured to append the routing token <code>456</code> to each
packet that passes through it, via the power of a
<a href="deployment/quickstarts/../../services/proxy/filters/concatenate.html">Concatenate</a> Filter.</p>
<p>Download <code>client-token.yaml</code> locally, so you can edit it:</p>
<pre><code class="language-shell">curl https://raw.githubusercontent.com/googleforgames/quilkin/main/examples/agones-xonotic-relay/client-token.yaml --output client-token.yaml  
</code></pre>
<p>We then take the EXTERNAL-IP and port from the <code>quilkin-proxies</code> service, and replace the<code>${LOADBALANCER_IP}</code>
with it in <code>client-token.yaml</code>.</p>
<p>Run this edited configuration locally with your quilkin binary as <code>quilkin -c ./client-token.yaml proxy</code>:</p>
<pre><code class="language-shell">$ ./quilkin --config ./client-token.yaml proxy
2023-10-04T20:09:07.320780Z  INFO quilkin::cli: src/cli.rs: Starting Quilkin version="0.7.0-dev" commit="d42db7e14c2e0e758e9a6eb655ccf4184941066c"
2023-10-04T20:09:07.321711Z  INFO quilkin::admin: src/admin.rs: Starting admin endpoint address=[::]:8000
2023-10-04T20:09:07.322089Z  INFO quilkin::cli::proxy: src/cli/proxy.rs: Starting port=7777 proxy_id="markmandel45"
2023-10-04T20:09:07.322576Z  INFO quilkin::cli::proxy: src/cli/proxy.rs: Quilkin is ready
2023-10-04T20:09:07.322692Z  INFO qcmp_task{v4_addr=0.0.0.0:7600 v6_addr=[::]:7600}: quilkin::protocol: src/protocol.rs: awaiting qcmp packets v4_addr=0.0.0.0:7600 v6_addr=[::]:7600
</code></pre>
<p>Now connect to the local client proxy on "[::1]:7777" via the "Multiplayer &gt; Address" field in the
Xonotic client, and Quilkin will take care of appending the routing token to all your UDP packets, which the Quilkin
proxies will route to the Allocated GameServer, and you can play a gamee!</p>
<p><img src="deployment/quickstarts/xonotic-address-v6.png" alt="xonotic-address-v6.png" /></p>
<p>...And you didn't have to change the client or the dedicated game server ü§∏</p>
<h2 id="whats-next-2"><a class="header" href="#whats-next-2">What's Next?</a></h2>
<ul>
<li>Check out the variety of <a href="deployment/quickstarts/../../services/proxy/filters.html">Filters</a> that are possible with Quilkin.</li>
<li>Read into the <a href="deployment/quickstarts/../../services/xds.html">xDS Management API</a>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proxy"><a class="header" href="#proxy">Proxy</a></h1>
<div class="table-wrapper"><table><thead><tr><th>Services</th><th>Ports</th><th>Protocol</th></tr></thead><tbody>
<tr><td>Proxy</td><td>7777</td><td>UDP (IPv4 OR IPv6)</td></tr>
<tr><td>QCMP</td><td>7600</td><td>UDP (IPv4 OR IPv6)</td></tr>
</tbody></table>
</div>
<p>"Proxy" is the primary Quilkin service, which acts as a non-transparent UDP
proxy.</p>
<p>To view all the options for the <code>proxy</code> subcommand, run:</p>
<pre><code class="language-shell">$ quilkin proxy --help
Run Quilkin as a UDP reverse proxy

Usage: quilkin proxy [OPTIONS]

Options:
  -m, --management-server &lt;MANAGEMENT_SERVER&gt;
          One or more `quilkin manage` endpoints to listen to for config changes [env: QUILKIN_MANAGEMENT_SERVER=]
      --mmdb &lt;MMDB&gt;
          The remote URL or local file path to retrieve the Maxmind database [env: MMDB=]
  -p, --port &lt;PORT&gt;
          The port to listen on [env: QUILKIN_PORT=] [default: 7777]
  -q, --qcmp-port &lt;QCMP_PORT&gt;
          The port to listen on [env: QUILKIN_QCMP_PORT=] [default: 7600]
  -t, --to &lt;TO&gt;
          One or more socket addresses to forward packets to [env: QUILKIN_DEST=]
      --idle-request-interval-secs &lt;IDLE_REQUEST_INTERVAL_SECS&gt;
          The interval in seconds at which the relay will send a discovery request to an management server after receiving no updates [env: QUILKIN_IDLE_REQUEST_INTERVAL_SECS=]
  -w, --workers &lt;WORKERS&gt;
          Number of worker threads used to process packets. If not specified defaults to number of cpus [env: QUILKIN_WORKERS=]
  -h, --help
          Print help
</code></pre>
<h2 id="endpoints"><a class="header" href="#endpoints">Endpoints</a></h2>
<p>An Endpoint represents an address that Quilkin forwards packets to that it has received from the
source port.</p>
<p>It is represented by an IP address and port. An Endpoint can optionally be associated with an arbitrary set of
<a href="services/proxy.html#endpoint-metadata">metadata</a> as well.</p>
<h2 id="proxy-filters"><a class="header" href="#proxy-filters">Proxy Filters</a></h2>
<p>Filters are the way for a Quilkin proxy to intercept UDP packet traffic from the
source and <a href="services/proxy.html#endpoints">Endpoints</a> in either direction, and be able to inspect,
manipulate, and route the packets as desired.</p>
<p>See <a href="services/./proxy/filters.html">Filters</a>  for a deeper dive into Filters, as well as the list of build in Filters that come with
Quilkin.</p>
<h2 id="endpoint-metadata"><a class="header" href="#endpoint-metadata">Endpoint Metadata</a></h2>
<p>Endpoint metadata is an arbitrary set of key value pairs that are associated with an Endpoint.</p>
<p>These are visible to Filters when processing packets and can be used to provide more context about endpoints (e.g
whether or not to route a packet to an endpoint). Keys must be of type string otherwise the configuration is rejected.</p>
<p>Metadata associated with an endpoint contain arbitrary key value pairs which <a href="services/./proxy/filters.html">Filters</a> can consult when processing packets (e.g they can contain information that determine whether or not to route a particular packet to an endpoint).</p>
<h3 id="specialist-endpoint-metadata"><a class="header" href="#specialist-endpoint-metadata">Specialist Endpoint Metadata</a></h3>
<p>Access tokens that can be associated with an endpoint are simply a special piece of metadata well known to Quilkin
and utilised by the built-in <a href="services/./proxy/filters/token_router.html">TokenRouter</a> filter to route packets.</p>
<p>Such well known values are placed within an object in the endpoint metadata, under the special key <code>quilkin.dev</code>.
Currently, only the <code>tokens</code> key is in use.</p>
<p>As an example, the following shows the configuration for an endpoint with its metadata:</p>
<pre><code class="language-yaml">clusters:
  - endpoints:
    - address: 127.0.0.1:26000
      metadata:
        canary: false
        quilkin.dev: # This object is extracted by Quilkin and is usually reserved for built-in features
            tokens:
            - MXg3aWp5Ng== # base64 for 1x7ijy6
            - OGdqM3YyaQ== # base64 for 8gj3v2i
</code></pre>
<p>An endpoint's metadata can be specified alongside the endpoint in <a href="services/./proxy/configuration.html">static configuration</a> or using the <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/endpoint/v3/endpoint_components.proto#envoy-v3-api-field-config-endpoint-v3-lbendpoint-metadata">xDS endpoint metadata</a> field when using <a href="services/./xds.html">dynamic configuration</a> via xDS.</p>
<h2 id="session"><a class="header" href="#session">Session</a></h2>
<p>A session represents ongoing communication flow between a client on a [Local Port] and an <a href="services/proxy.html#endpoints">Endpoint</a>.</p>
<p>Quilkin uses the "Session" concept to track traffic flowing through the proxy between any client-server pair. A
Session serves the same purpose, and can be thought of as a lightweight version of a <code>TCP</code> session in that, while a
TCP session requires a protocol to establish and teardown:</p>
<ul>
<li>A Quilkin session is automatically created upon receiving the first packet from a client via the [Local Port] to be
sent to an upstream <a href="services/proxy.html#endpoints">Endpoint</a>.</li>
<li>The session is automatically deleted after a period of inactivity (where no packet was sent between either
party) - currently 60 seconds.</li>
</ul>
<p>A session is identified by the 4-tuple <code>(client IP, client Port, server IP, server Port)</code> where the client is the
downstream endpoint which initiated the communication with Quilkin and the server is one of the upstream Endpoints
that Quilkin proxies traffic to.</p>
<p>Sessions are established <em>after</em> the filter chain completes. The destination Endpoint of a packet is determined by
the <a href="services/./proxy/filters.html">filter chain</a>, so a Session can only be created after filter chain completion. For example, if the
filter chain drops all packets, then no session will ever be created.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="configuration-file"><a class="header" href="#configuration-file">Configuration File</a></h1>
<p>While much of Quilkin's proxy configuration can be configured via its
<a href="services/proxy/../proxy.html">command line interface</a>, if you have a larger or more complex configuration
it might be useful to use a configuration file instead.</p>
<p>The following is the schema and reference for Quilkin's proxy configuration
file. See the <a href="https://github.com/googleforgames/quilkin/blob/main/examples">examples</a> folder for example configuration files.</p>
<p>By default, Quilkin will look for a configuration file named <code>quilkin.yaml</code> in
its current running directory first, then if not present, in
<code>/etc/quilkin/quilkin.yaml</code> on UNIX systems. This can be overridden with the
<code>-c/--config</code> command-line argument, or the <code>QUILKIN_FILENAME</code>
environment variable.</p>
<h2 id="static-configuration"><a class="header" href="#static-configuration">Static Configuration</a></h2>
<p>Example of a full configuration for <code>quilkin proxy</code> that utlisies a static
endpoint configuration to specify two endpoints with <code>token</code> metadata attached to each:</p>
<pre><code class="language-yaml">#
# Example configuration for a Quilkin Proxy with static Endpoints
#

version: v1alpha1
id: my-proxy # An identifier for the proxy instance.
clusters: # grouping of clusters
  - endpoints: # array of potential endpoints to send on traffic to
    - address: 127.0.0.1:26000
      metadata: # Metadata associated with the endpoint
        quilkin.dev:
          tokens:
            - MXg3aWp5Ng== # the connection byte array to route to, encoded as base64 (string value: 1x7ijy6)
            - OGdqM3YyaQ== # (string value: 8gj3v2i)
    - address: 127.0.0.1:26001
      metadata: # Metadata associated with the endpoint
        quilkin.dev:
          tokens:
            - bmt1eTcweA== # (string value: nkuy70x)
</code></pre>
<p>This is a great use of a static configuration file, as we only get a singular <code>--to</code> endpoint address via the
command line arguments.</p>
<p>We can also configure <a href="services/proxy/./filters.html">Filters</a> via the configuration file. See that section for documentation.</p>
<h2 id="dynamic-configuration"><a class="header" href="#dynamic-configuration">Dynamic Configuration</a></h2>
<p>If you need to dynamically change either Filters and/or Endpoints at runtime, see the <a href="services/proxy/../xds.html">Control Plane</a>
documentation on the configuration API surface, and built in dynamic management providers.</p>
<h2 id="json-schema"><a class="header" href="#json-schema">Json Schema</a></h2>
<p>The full <a href="https://json-schema.org/">JSON Schema</a> for the YAML configuration file.</p>
<pre><code class="language-yaml">type: object
properties:
  version:
    type: string
    description: |
      The configuration file version to use.
    enum:
      - v1alpha1
  id:
      type: string
      description: |
          An identifier for the proxy instance.
      default: On linux, the machine hostname is used as default. On all other platforms a UUID is generated for the proxy.
  port:
      type: integer
      description: |
          The listening port. In "proxy" mode, the port for traffic to be sent to. In "manage" mode, the port to connect to the xDS API.
      default: 7000
  maxmind_db:
    type: string
    description: |
      The remote URL or local file path to retrieve the Maxmind database (requires licence).
  filters:
    type: array
    description: |
      A filter chain.
    items:
      '$ref': {} # Refer to the Filter documentation for a filter configuration schema.
  clusters:
    type: array
    description: |
      grouping of endpoints, per cluster.
    items:
      type: object
      properties:
        endpoints:
          type: array
          description: |
            A list of upstream endpoints to forward packets to.
          items:
            type: object
            description: |
              An upstream endpoint
            properties:
              address:
                type: string
                description: |
                  Socket address of the endpoint. This must be of the ¬¥IP:Port` form e.g `192.168.1.1:7001`
                metadata:
                  type: object
                  description: |
                    Arbitrary key value pairs that is associated with the endpoint.
                    These are visible to Filters when processing packets and can be used to provide more context about endpoints (e.g whether or not to route a packet to an endpoint).
                    Keys must be of type string otherwise the configuration is rejected.
            required:
              - address
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="packet-filters"><a class="header" href="#packet-filters">Packet Filters</a></h1>
<p>In most cases, we would like Quilkin to do some preprocessing of received packets before sending them off to their destination. Because this stage is entirely specific to the use case at hand and differs between Quilkin deployments, we must have a say over what tweaks to perform - this is where filters come in.</p>
<h2 id="filters-and-filter-chain"><a class="header" href="#filters-and-filter-chain">Filters and Filter chain</a></h2>
<p>A filter represents a step in the tweaking/decision-making process of how we would like to process our packets. For example, at some step, we might choose to append some metadata to every packet we receive before forwarding it while at a later step, choose not to forward packets that don't meet some criteria.</p>
<p>Quilkin lets us specify any number of filters and connect them in a sequence to form a packet processing pipeline similar to a <a href="https://en.wikipedia.org/wiki/Pipeline_(Unix)" target="_blank">Unix pipeline</a> - we call this pipeline a <code>Filter chain</code>. The combination of filters and filter chain allows us to add new functionality to fit every scenario without changing Quilkin's core.</p>
<p>As an example, say we would like to perform the following steps in our processing pipeline to the packets we receive.</p>
<ul>
<li>Append a predetermined byte to the packet.</li>
<li>Compress the packet.</li>
<li>Do not forward (drop) the packet if its compressed length is over 512 bytes.</li>
</ul>
<p>We would create a filter corresponding to each step either by leveraging any <a href="services/proxy/filters.html#built-in-filters">existing filters</a>
that do what we want or <a href="services/proxy/./filters/writing_custom_filters.html">writing one ourselves</a> and connect them to form the
following filter chain:</p>
<pre><code class="language-bash">append | compress | drop
</code></pre>
<p>When Quilkin consults our filter chain, it feeds the received packet into <code>append</code> and forwards the packet it receives (if any) from <code>drop</code> - i.e the output of <code>append</code> becomes the <code>input</code> into <code>compress</code> and so on in that order.</p>
<p>There are a few things we note here:</p>
<ul>
<li>
<p>Although we have in this example, a filter called <code>drop</code>, every filter in the filter chain has the same ability to <em>drop</em> or <em>update</em> a packet - if any filter drops a packet then no more work needs to be done regarding that packet so the next filter in the pipeline never has any knowledge that the dropped packet ever existed.</p>
</li>
<li>
<p>The filter chain is consulted for every received packet, and its filters are traversed in reverse order for packets travelling in the opposite direction.
A packet received downstream will be fed into <code>append</code> and the result from <code>drop</code> is forwarded upstream - a packet received upstream will be fed into <code>drop</code> and the result from <code>append</code> is forwarded downstream.</p>
</li>
<li>
<p>Exactly one filter chain is specified and used to process all packets that flow through Quilkin.</p>
</li>
</ul>
<h2 id="configuration-examples"><a class="header" href="#configuration-examples">Configuration Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// Wrap this example within an async main function since the
</span><span class="boring">// local_rate_limit filter spawns a task on initialization
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">let yaml = "
</span>version: v1alpha1
filters:
  - name: quilkin.filters.debug.v1alpha1.Debug
    config:
      id: debug-1
  - name: quilkin.filters.local_rate_limit.v1alpha1.LocalRateLimit
    config:
      max_packets: 10
      period: 1
clusters:
  - endpoints:
    - address: 127.0.0.1:7001
<span class="boring">";
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.filters.load().len(), 2);
</span><span class="boring">}</span></code></pre></pre>
<p>We specify our filter chain in the <code>.filters</code> section of the proxy's configuration which has takes a sequence of <a href="services/proxy/filters.html#filter-config">FilterConfig</a> objects. Each object describes all information necessary to create a single filter.</p>
<p>The above example creates a filter chain comprising a <a href="services/proxy/./filters/debug.html">Debug</a> filter followed by a <a href="services/proxy/./filters/local_rate_limit.html">LocalRateLimit</a> filter - the effect is that every packet will be logged and the proxy will not forward more than 10 packets per second.</p>
<blockquote>
<p>The sequence determines the filter chain order so its ordering matters - the chain starts with the filter corresponding the first filter config and ends with the filter corresponding the last filter config in the sequence.</p>
</blockquote>
<h2 id="filter-dynamic-metadata"><a class="header" href="#filter-dynamic-metadata">Filter Dynamic Metadata</a></h2>
<p>A filter within the filter chain can share data within another filter further along in the filter chain by propagating the desired data alongside the packet being processed.
This enables sharing dynamic information at runtime, e.g information about the current packet that might be useful to other filters that process that packet.</p>
<p>At packet processing time each packet is associated with <em>filter dynamic metadata</em> (a set of key-value pairs). Each key is a unique string while its value is an associated <a href="services/proxy/../../../api/quilkin/net/endpoint/metadata/enum.Value.html"><code>quilkin::metadata::Value</code></a>.
When a filter processes a packet, it can choose to consult the associated dynamic metadata for more information or itself add/update or remove key-values from the set.</p>
<p>As an example, the built-in [CaptureBytes] filter is one such filter that populates a packet's filter metadata.
[CaptureBytes] extracts information (a configurable byte sequence) from each packet and appends it to the packet's dynamic metadata for other filters to leverage.
On the other hand, the built-in <a href="services/proxy/./filters/token_router.html">TokenRouter</a> filter selects what endpoint to route a packet by consulting the packet's dynamic metadata for a routing token.
Consequently, we can build a filter chain with a [CaptureBytes] filter preceeding a <a href="services/proxy/./filters/token_router.html">TokenRouter</a> filter, both configured to write and read the same key in the dynamic metadata entry. The effect would be that packets are routed to upstream endpoints based on token information extracted from their contents.</p>
<h3 id="well-known-dynamic-metadata"><a class="header" href="#well-known-dynamic-metadata">Well Known Dynamic Metadata</a></h3>
<p>The following metadata are currently used by Quilkin core and built-in filters.</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th>Type</th><th>Description</th></tr></thead><tbody>
<tr><td><code>quilkin.dev/captured</code></td><td><code>Bytes</code></td><td>The default key under which the <a href="services/proxy/./filters/capture.html">Capture</a> filter puts the byte slices it extracts from each packet.</td></tr>
</tbody></table>
</div>
<h2 id="built-in-filters"><a class="header" href="#built-in-filters">Built-in filters <a name="built-in-filters"></a></a></h2>
<p>Quilkin includes several filters out of the box.</p>
<div class="table-wrapper"><table><thead><tr><th>Filter</th><th>Description</th></tr></thead><tbody>
<tr><td><a href="services/proxy/./filters/capture.html">Capture</a></td><td>Capture specific bytes from a packet and store them in <a href="services/proxy/filters.html#filter-dynamic-metadata">filter dynamic metadata</a>.</td></tr>
<tr><td><a href="services/proxy/./filters/compress.html">Compress</a></td><td>Compress and decompress packets data.</td></tr>
<tr><td><a href="services/proxy/./filters/concatenate.html">Concatenate</a></td><td>Add authentication tokens to packets.</td></tr>
<tr><td><a href="services/proxy/./filters/debug.html">Debug</a></td><td>Logs every packet.</td></tr>
<tr><td><a href="services/proxy/./filters/drop.html">Drop</a></td><td>Drop all packets</td></tr>
<tr><td><a href="services/proxy/./filters/firewall.html">Firewall</a></td><td>Allowing/blocking traffic by IP and port.</td></tr>
<tr><td><a href="services/proxy/./filters/load_balancer.html">LoadBalancer</a></td><td>Distributes downstream packets among upstream endpoints.</td></tr>
<tr><td><a href="services/proxy/./filters/local_rate_limit.html">LocalRateLimit</a></td><td>Limit the frequency of packets.</td></tr>
<tr><td><a href="services/proxy/./filters/match.html">Match</a></td><td>Change Filter behaviour based on dynamic metadata</td></tr>
<tr><td><a href="services/proxy/./filters/pass.html">Pass</a></td><td>Allow all packets through</td></tr>
<tr><td><a href="services/proxy/./filters/timestamp.html">Timestamp</a></td><td>Accepts a UNIX timestamp from metadata and observes the duration between that timestamp and now.</td></tr>
<tr><td><a href="services/proxy/./filters/token_router.html">TokenRouter</a></td><td>Send packets to endpoints based on metadata.</td></tr>
</tbody></table>
</div>
<h2 id="filterconfig"><a class="header" href="#filterconfig">FilterConfig <a name="filter-config"></a></a></h2>
<p>Represents configuration for a filter instance.</p>
<pre><code class="language-yaml">properties:
  name:
    type: string
    description: |
      Identifies the type of filter to be created.
      This value is unique for every filter type - please consult the documentation for the particular filter for this value.

  config:
    type: object
    description: |
      The configuration value to be passed onto the created filter.
      This is passed as an object value since it is specific to the filter's type and is validated by the filter
      implementation. Please consult the documentation for the particular filter for its schema.

required: [ 'name' ]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="capture"><a class="header" href="#capture">Capture</a></h1>
<p>The <code>Capture</code> filter's job is to find a series of bytes within a packet, and capture it into
<a href="services/proxy/filters/../filters.html#filter-dynamic-metadata">Filter Dynamic Metadata</a>, so that it can be utilised by filters further
down the chain.</p>
<p>This is often used as a way of retrieving authentication tokens from a packet, and used in combination with
<a href="services/proxy/filters/concatenate.html">Concatenate</a> and
<a href="services/proxy/filters/token_router.html">TokenRouter</a> filter to provide common packet routing utilities.</p>
<h2 id="capture-strategies"><a class="header" href="#capture-strategies">Capture strategies</a></h2>
<p>There are multiple strategies for capturing bytes from the packet.</p>
<h3 id="suffix"><a class="header" href="#suffix">Suffix</a></h3>
<p>Captures bytes from the end of the packet.</p>
<h3 id="prefix"><a class="header" href="#prefix">Prefix</a></h3>
<p>Captures bytes from the start of the packet.</p>
<h3 id="regex"><a class="header" href="#regex">Regex</a></h3>
<p>Captures bytes using a regular expression. Unlike other capture strategies,
the regular expression can return one or many values if there are
multiple matches.</p>
<h2 id="filter-name"><a class="header" href="#filter-name">Filter name</a></h2>
<pre><code class="language-text">quilkin.filters.capture.v1alpha1.Capture
</code></pre>
<h2 id="configuration-examples-1"><a class="header" href="#configuration-examples-1">Configuration Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = "
</span>version: v1alpha1
filters:
  - name: quilkin.filters.capture.v1alpha1.Capture
    config:
      metadataKey: myapp.com/myownkey
      prefix:
        size: 3
        remove: false
clusters:
  - endpoints:
      - address: 127.0.0.1:7001
<span class="boring">";
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.filters.load().len(), 1);
</span><span class="boring">}</span></code></pre></pre>
<h2 id="configuration-options-rust-doc"><a class="header" href="#configuration-options-rust-doc">Configuration Options (<a href="services/proxy/filters/../../../../api/quilkin/filters/capture/struct.Config.html">Rust Doc</a>)</a></h2>
<pre><code class="language-yaml">$schema: http://json-schema.org/draft-07/schema#
title: Config
type: object
required:
- metadata_key
- strategy
properties:
  metadata_key:
    description: The key to use when storing the captured value in the filter context. If a match was found it is available under `{{metadata_key}}/is_present`.
    allOf:
    - $ref: '#/definitions/Key'
  strategy:
    description: The capture strategy.
    allOf:
    - $ref: '#/definitions/Strategy'
definitions:
  Key:
    description: A key in the metadata table.
    type: string
  Strategy:
    description: Strategy to apply for acquiring a set of bytes in the UDP packet
    oneOf:
    - description: Looks for the set of bytes at the beginning of the packet
      type: object
      required:
      - kind
      - size
      properties:
        kind:
          type: string
          enum:
          - PREFIX
        remove:
          description: Whether captured bytes are removed from the original packet.
          default: false
          type: boolean
        size:
          description: The number of bytes to capture.
          type: integer
          format: uint32
          minimum: 0.0
    - description: Look for the set of bytes at the end of the packet
      type: object
      required:
      - kind
      - size
      properties:
        kind:
          type: string
          enum:
          - SUFFIX
        remove:
          description: The number of bytes to capture.
          default: false
          type: boolean
        size:
          description: Whether captured bytes are removed from the original packet.
          type: integer
          format: uint32
          minimum: 0.0
    - description: Look for the set of bytes at the end of the packet
      type: object
      required:
      - kind
      - pattern
      properties:
        kind:
          type: string
          enum:
          - REGEX
        pattern:
          description: The regular expression to use for capture.
          type: string
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compress"><a class="header" href="#compress">Compress</a></h1>
<p>The <code>Compress</code> filter's job is to provide a variety of compression implementations for compression
and subsequent decompression of UDP data when sent between systems, such as a game client and game server.</p>
<h2 id="filter-name-1"><a class="header" href="#filter-name-1">Filter name</a></h2>
<pre><code class="language-text">quilkin.filters.compress.v1alpha1.Compress
</code></pre>
<h2 id="configuration-examples-2"><a class="header" href="#configuration-examples-2">Configuration Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = "
</span>version: v1alpha1
filters:
  - name: quilkin.filters.compress.v1alpha1.Compress
    config:
        on_read: COMPRESS
        on_write: DECOMPRESS
        mode: SNAPPY
clusters:
  - endpoints:
    - address: 127.0.0.1:7001
<span class="boring">";
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.filters.load().len(), 1);
</span><span class="boring">}</span></code></pre></pre>
<p>The above example shows a proxy that could be used with a typical game client, where the original client data is
sent to the local listening port and then compressed when heading up to a dedicated game server, and then
decompressed when traffic is returned from the dedicated game server before being handed back to game client.</p>
<blockquote>
<p>It is worth noting that since the Compress filter modifies the <em>entire packet</em>, it is worth paying special
attention to the order it is placed in your <a href="services/proxy/filters/../filters.html">Filter configuration</a>. Most of the time it will likely be
the first or last Filter configured to ensure it is compressing the entire set of data being sent.</p>
</blockquote>
<h2 id="configuration-options-rust-doc-1"><a class="header" href="#configuration-options-rust-doc-1">Configuration Options (<a href="services/proxy/filters/../../../../api/quilkin/filters/compress/struct.Config.html">Rust Doc</a>)</a></h2>
<pre><code class="language-yaml">$schema: http://json-schema.org/draft-07/schema#
title: Config
type: object
required:
- on_read
- on_write
properties:
  mode:
    default: SNAPPY
    allOf:
    - $ref: '#/definitions/Mode'
  on_read:
    $ref: '#/definitions/Action'
  on_write:
    $ref: '#/definitions/Action'
definitions:
  Action:
    description: Whether to do nothing, compress or decompress the packet.
    type: string
    enum:
    - DO_NOTHING
    - COMPRESS
    - DECOMPRESS
  Mode:
    description: The library to use when compressing.
    type: string
    enum:
    - SNAPPY
    - LZ4
</code></pre>
<h2 id="compression-modes"><a class="header" href="#compression-modes">Compression Modes</a></h2>
<h3 id="snappy"><a class="header" href="#snappy">Snappy</a></h3>
<blockquote>
<p>Snappy is a compression/decompression library. It does not aim for maximum compression, or compatibility with any
other compression library; instead, it aims for very high speeds and reasonable compression.</p>
</blockquote>
<p>This compression method is provided by <a href="https://github.com/BurntSushi/rust-snappy">rust-snappy</a>.</p>
<p>Due to the small size of packets, this only encodes and decodes the non-streaming version of the format described <a href="https://github.com/google/snappy/blob/main/format_description.txt">here</a>.</p>
<pre><code class="language-yaml">- name: quilkin.filters.compress.v1alpha1.Compress
    config:
        on_read: COMPRESS
        on_write: DECOMPRESS
        mode: SNAPPY
</code></pre>
<h3 id="lz4"><a class="header" href="#lz4">LZ4</a></h3>
<blockquote>
<p>LZ4 is lossless compression algorithm, providing compression speed &gt; 500 MB/s per core, scalable with multi-cores CPU.
It features an extremely fast decoder, with speed in multiple GB/s per core, typically reaching RAM speed limits on
multi-core systems.</p>
</blockquote>
<p>This compression method is provided by <a href="https://github.com/PSeitz/lz4_flex">lz4_flex</a>.</p>
<p>Due to the small size of packets, this only encodes and decodes the block version of the format described. If your game client/server itself is performing LZ4 de/compression it needs to encode or
decode a varint of the uncompressed packet size (maximum 2^16) since that is not part of the LZ4 block
format. The varint is of the same exact form as that used by <a href="https://github.com/google/snappy/blob/27f34a580be4a3becf5f8c0cba13433f53c21337/format_description.txt#L20-L25">snappy</a>.</p>
<pre><code class="language-yaml">- name: quilkin.filters.compress.v1alpha1.Compress
    config:
        on_read: COMPRESS
        on_write: DECOMPRESS
        mode: LZ4
</code></pre>
<h2 id="metrics"><a class="header" href="#metrics">Metrics</a></h2>
<ul>
<li><code>quilkin_filter_int_counter{label="compressed_bytes_total"}</code>
Total number of compressed bytes either received or sent.</li>
<li><code>quilkin_filter_int_counter{label="decompressed_bytes_total"}</code>
Total number of decompressed bytes either received or sent.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="concatenate"><a class="header" href="#concatenate">Concatenate</a></h1>
<p>The <code>Concatenate</code> filter's job is to add a byte packet to either the beginning or end of each UDP packet that passes
through. This is commonly used to provide an auth token to each packet, so they can be routed appropriately.</p>
<h2 id="filter-name-2"><a class="header" href="#filter-name-2">Filter name</a></h2>
<pre><code class="language-text">quilkin.filters.concatenate.v1alpha1.Concatenate
</code></pre>
<h2 id="configuration-examples-3"><a class="header" href="#configuration-examples-3">Configuration Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = "
</span>version: v1alpha1
filters:
  - name: quilkin.filters.concatenate.v1alpha1.Concatenate
    config:
        on_read: APPEND
        on_write: DO_NOTHING
        bytes: MXg3aWp5Ng==
clusters:
  - endpoints:
      - address: 127.0.0.1:7001
<span class="boring">";
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.filters.load().len(), 1);
</span><span class="boring">}</span></code></pre></pre>
<h2 id="configuration-options-rust-doc-2"><a class="header" href="#configuration-options-rust-doc-2">Configuration Options (<a href="services/proxy/filters/../../../../api/quilkin/filters/concatenate/struct.Config.html">Rust Doc</a>)</a></h2>
<pre><code class="language-yaml">$schema: http://json-schema.org/draft-07/schema#
title: Config
description: Config represents a `Concatenate` filter configuration.
type: object
required:
- bytes
properties:
  bytes:
    type: array
    items:
      type: integer
      format: uint8
      minimum: 0.0
  on_read:
    description: Whether or not to `append` or `prepend` or `do nothing` on Filter `Read`
    default: DO_NOTHING
    allOf:
    - $ref: '#/definitions/Strategy'
  on_write:
    description: Whether or not to `append` or `prepend` or `do nothing` on Filter `Write`
    default: DO_NOTHING
    allOf:
    - $ref: '#/definitions/Strategy'
definitions:
  Strategy:
    type: string
    enum:
    - APPEND
    - PREPEND
    - DO_NOTHING
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debug"><a class="header" href="#debug">Debug</a></h1>
<p>The Debug filter logs all incoming and outgoing packets to standard output.</p>
<p>This filter is useful in debugging deployments where the packets strictly contain valid <code>UTF-8</code> encoded strings. A generic error message is instead logged if conversion from bytes to <code>UTF-8</code> fails.</p>
<h3 id="filter-name-3"><a class="header" href="#filter-name-3">Filter name</a></h3>
<pre><code class="language-text">quilkin.filters.debug_filter.v1alpha1.Debug
</code></pre>
<h2 id="configuration-examples-4"><a class="header" href="#configuration-examples-4">Configuration Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = "
</span>version: v1alpha1
filters:
  - name: quilkin.filters.debug.v1alpha1.Debug
    config:
      id: debug-1
clusters:
  - endpoints:
      - address: 127.0.0.1:7001
<span class="boring">";
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.filters.load().len(), 1);
</span><span class="boring">}</span></code></pre></pre>
<h2 id="configuration-options-rust-doc-3"><a class="header" href="#configuration-options-rust-doc-3">Configuration Options (<a href="services/proxy/filters/../../../../api/quilkin/filters/debug/struct.Config.html">Rust Doc</a>)</a></h2>
<pre><code class="language-yaml">$schema: http://json-schema.org/draft-07/schema#
title: Config
description: A Debug filter's configuration.
type: object
properties:
  id:
    description: Identifier that will be optionally included with each log message.
    type:
    - string
    - 'null'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drop"><a class="header" href="#drop">Drop</a></h1>
<p>The <code>Drop</code> filter always drops any packet passed through it. This is useful in
combination with conditional flow filters like <a href="services/proxy/filters/match.html"><code>Matches</code></a></p>
<h2 id="filter-name-4"><a class="header" href="#filter-name-4">Filter name</a></h2>
<pre><code class="language-text">quilkin.filters.drop.v1alpha1.Drop
</code></pre>
<h2 id="configuration-examples-5"><a class="header" href="#configuration-examples-5">Configuration Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = "
</span>version: v1alpha1
clusters: 
  - endpoints:
    - address: 127.0.0.1:26000
    - address: 127.0.0.1:26001
filters:
  - name: quilkin.filters.capture.v1alpha1.Capture
    config:
      metadataKey: myapp.com/token
      prefix:
        size: 3
        remove: false
  - name: quilkin.filters.match.v1alpha1.Match
    config:
      on_read:
        metadataKey: myapp.com/token
        branches:
          - value: abc
            name: quilkin.filters.pass.v1alpha1.Pass
        fallthrough:
          name: quilkin.filters.drop.v1alpha1.Drop
<span class="boring">";
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.filters.load().len(), 2);
</span><span class="boring">}</span></code></pre></pre>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>No defined configuration options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="firewall"><a class="header" href="#firewall">Firewall</a></h1>
<p>The <code>Firewall</code> filter's job is to allow or block traffic depending on if the incoming traffic's IP and port matches
the rules set on the Firewall filter.</p>
<h2 id="filter-name-5"><a class="header" href="#filter-name-5">Filter name</a></h2>
<pre><code class="language-text">quilkin.filters.firewall.v1alpha1.Firewall
</code></pre>
<h2 id="configuration-examples-6"><a class="header" href="#configuration-examples-6">Configuration Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = "
</span>version: v1alpha1
filters:
  - name: quilkin.filters.firewall.v1alpha1.Firewall
    config:
      on_read:
        - action: ALLOW
          sources:
            - 192.168.51.0/24
          ports:
            - 10
            - 1000-7000
      on_write:
        - action: DENY
          sources:
            - 192.168.51.0/24
          ports:
            - 7000
clusters:
  - endpoints:
      - address: 127.0.0.1:7001
<span class="boring">";
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.filters.load().len(), 1);
</span><span class="boring">}</span></code></pre></pre>
<h2 id="configuration-options-rust-doc-4"><a class="header" href="#configuration-options-rust-doc-4">Configuration Options (<a href="services/proxy/filters/../../../../api/quilkin/filters/firewall/struct.Config.html">Rust Doc</a>)</a></h2>
<pre><code class="language-yaml">$schema: http://json-schema.org/draft-07/schema#
title: Config
description: Represents how a Firewall filter is configured for read and write operations.
type: object
required:
- on_read
- on_write
properties:
  on_read:
    type: array
    items:
      $ref: '#/definitions/Rule'
  on_write:
    type: array
    items:
      $ref: '#/definitions/Rule'
definitions:
  Action:
    description: Whether or not a matching [Rule] should Allow or Deny access
    oneOf:
    - description: Matching rules will allow packets through.
      type: string
      enum:
      - ALLOW
    - description: Matching rules will block packets.
      type: string
      enum:
      - DENY
  Cidr:
    description: Cidr notation for an ipv6 or ipv4 netmask
    type: string
  PortRange:
    description: Range of matching ports that are configured against a [Rule].
    allOf:
    - $ref: '#/definitions/Range_of_uint16'
  Range_of_uint16:
    type: object
    required:
    - end
    - start
    properties:
      end:
        type: integer
        format: uint16
        minimum: 0.0
      start:
        type: integer
        format: uint16
        minimum: 0.0
  Rule:
    description: Combination of CIDR range, port range and action to take.
    type: object
    required:
    - action
    - ports
    - sources
    properties:
      action:
        $ref: '#/definitions/Action'
      ports:
        type: array
        items:
          $ref: '#/definitions/PortRange'
      sources:
        description: ipv4 or ipv6 CIDR address.
        type: array
        items:
          $ref: '#/definitions/Cidr'
</code></pre>
<h3 id="rule-evaluation"><a class="header" href="#rule-evaluation">Rule Evaluation</a></h3>
<p>The Firewall filter supports DENY and ALLOW actions for access control. When multiple DENY and ALLOW actions are used
for a workload at the same time, the evaluation is processed in the order it is configured, with the first matching
rule deciding if the request is allowed or denied:</p>
<ol>
<li>If a rule action is ALLOW, and it matches the request, then the entire request is allowed.</li>
<li>If a rule action is DENY and it matches the request, then the entire request is denied.</li>
<li>If none of the configured rules match, then the request is denied.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loadbalancer"><a class="header" href="#loadbalancer">LoadBalancer</a></h1>
<p>The <code>LoadBalancer</code> filter distributes packets received downstream among all upstream endpoints.</p>
<h2 id="filter-name-6"><a class="header" href="#filter-name-6">Filter name</a></h2>
<pre><code class="language-text">quilkin.filters.load_balancer.v1alpha1.LoadBalancer
</code></pre>
<h2 id="configuration-examples-7"><a class="header" href="#configuration-examples-7">Configuration Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">  let yaml = "
</span>version: v1alpha1
filters:
  - name: quilkin.filters.load_balancer.v1alpha1.LoadBalancer
    config:
      policy: ROUND_ROBIN
clusters:
  - endpoints:
      - address: 127.0.0.1:7001
<span class="boring">";
</span><span class="boring">  let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.filters.load().len(), 1);
</span><span class="boring">}</span></code></pre></pre>
<p>The load balancing policy (the strategy to use to select what endpoint to send traffic to) is configurable.
In the example above, packets will be distributed by selecting endpoints in turn, in round robin fashion.</p>
<h2 id="configuration-options-rust-doc-5"><a class="header" href="#configuration-options-rust-doc-5">Configuration Options (<a href="services/proxy/filters/../../../../api/quilkin/filters/load_balancer/struct.Config.html">Rust Doc</a>)</a></h2>
<pre><code class="language-yaml">$schema: http://json-schema.org/draft-07/schema#
title: Config
description: The configuration for [`load_balancer`][super].
type: object
properties:
  policy:
    default: ROUND_ROBIN
    allOf:
    - $ref: '#/definitions/Policy'
definitions:
  Policy:
    description: Policy represents how a [`load_balancer`][super] distributes packets across endpoints.
    oneOf:
    - description: Send packets to endpoints in turns.
      type: string
      enum:
      - ROUND_ROBIN
    - description: Send packets to endpoints chosen at random.
      type: string
      enum:
      - RANDOM
    - description: Send packets to endpoints based on hash of source IP and port.
      type: string
      enum:
      - HASH
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="localratelimit"><a class="header" href="#localratelimit">LocalRateLimit</a></h1>
<p>The LocalRateLimit filter controls the frequency at which packets received downstream are forwarded upstream by the proxy.
Rate limiting is done independently per source (IP, Port) combination.</p>
<h2 id="filter-name-7"><a class="header" href="#filter-name-7">Filter name</a></h2>
<pre><code class="language-text">quilkin.filters.local_rate_limit.v1alpha1.LocalRateLimit
</code></pre>
<h2 id="configuration-examples-8"><a class="header" href="#configuration-examples-8">Configuration Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// Wrap this example within an async main function since the
</span><span class="boring">// local_rate_limit filter spawns a task on initialization
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">  let yaml = "
</span>version: v1alpha1
filters:
  - name: quilkin.filters.local_rate_limit.v1alpha1.LocalRateLimit
    config:
      max_packets: 1000
      period: 1
clusters:
  - endpoints:
    - address: 127.0.0.1:7001
<span class="boring">";
</span><span class="boring">  let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.filters.load().len(), 1);
</span><span class="boring">}</span></code></pre></pre>
<p>To configure a rate limiter, we specify the maximum rate at which the proxy is allowed to forward packets. In the example above, we configured the proxy to forward a maximum of 1000 packets per second).</p>
<blockquote>
<p>Be aware that due to some optimizations in the current rate limiter implementation, the enforced maximum number of packets is not always exact.
It is in theory possible that the rate limiter allows a few packets through, however in practice this would be a rare occurrence
and the maximum number of such packets that is in the worse case <code>N-1</code> where <code>N</code> is the number of threads used to process packets.
For example, a configuration allowing 1000 packets per second could potentially allow 1004 packets during some time window if we have up to 4 threads.</p>
</blockquote>
<blockquote>
<p>Packets that that exceeds the maximum configured rate are dropped.</p>
</blockquote>
<h2 id="configuration-options-rust-doc-6"><a class="header" href="#configuration-options-rust-doc-6">Configuration Options (<a href="services/proxy/filters/../../../../api/quilkin/filters/local_rate_limit/struct.Config.html">Rust Doc</a>)</a></h2>
<pre><code class="language-yaml">$schema: http://json-schema.org/draft-07/schema#
title: Config
description: Config represents a [self]'s configuration.
type: object
required:
- max_packets
- period
properties:
  max_packets:
    description: The maximum number of packets allowed to be forwarded by the rate limiter in a given duration.
    type: integer
    format: uint
    minimum: 0.0
  period:
    description: The duration in seconds during which max_packets applies. If none is provided, it defaults to one second.
    type: integer
    format: uint32
    minimum: 0.0
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match"><a class="header" href="#match">Match</a></h1>
<p>The <code>Match</code> filter's job is to provide a mechanism to change behaviour based
on dynamic metadata. This filter behaves similarly to the <code>match</code> expression
in Rust or <code>switch</code> statements in other languages.</p>
<h2 id="filter-name-8"><a class="header" href="#filter-name-8">Filter name</a></h2>
<pre><code class="language-text">quilkin.filters.match.v1alpha1.Match
</code></pre>
<h2 id="configuration-examples-9"><a class="header" href="#configuration-examples-9">Configuration Examples</a></h2>
<!-- ANCHOR: example -->
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = "
</span>version: v1alpha1
clusters: 
  - endpoints:
    - address: 127.0.0.1:26000
    - address: 127.0.0.1:26001
filters:
  - name: quilkin.filters.capture.v1alpha1.Capture
    config:
      metadataKey: myapp.com/token
      prefix:
        size: 3
        remove: false
  - name: quilkin.filters.match.v1alpha1.Match
    config:
      on_read:
        metadataKey: myapp.com/token
        branches:
          - value: abc
            name: quilkin.filters.pass.v1alpha1.Pass
        fallthrough:
          name: quilkin.filters.drop.v1alpha1.Drop
<span class="boring">";
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.filters.load().len(), 2);
</span><span class="boring">}</span></code></pre></pre>
<!--  ANCHOR_END: example -->
<h2 id="configuration-options-rust-doc-7"><a class="header" href="#configuration-options-rust-doc-7">Configuration Options (<a href="services/proxy/filters/../../../../api/quilkin/filters/match/struct.Config.html">Rust Doc</a>)</a></h2>
<pre><code class="language-yaml">$schema: http://json-schema.org/draft-07/schema#
title: Config
description: Configuration for [`Match`][super::Match].
type: object
properties:
  on_read:
    description: Configuration for [`Filter::read`][crate::filters::Filter::read].
    anyOf:
    - $ref: '#/definitions/DirectionalConfig'
    - type: 'null'
  on_write:
    description: Configuration for [`Filter::write`][crate::filters::Filter::write].
    anyOf:
    - $ref: '#/definitions/DirectionalConfig'
    - type: 'null'
additionalProperties: false
definitions:
  Branch:
    description: A specific match branch. The filter is run when `value` matches the value defined in `metadata_key`.
    type: object
    required:
    - name
    - value
    properties:
      config: true
      label:
        type:
        - string
        - 'null'
      name:
        type: string
      value:
        description: The value to compare against the dynamic metadata.
        allOf:
        - $ref: '#/definitions/Value'
  DirectionalConfig:
    description: Configuration for a specific direction.
    type: object
    required:
    - branches
    - metadataKey
    properties:
      branches:
        description: List of filters to compare and potentially run if any match.
        type: array
        items:
          $ref: '#/definitions/Branch'
      fallthrough:
        description: The behaviour for when none of the `branches` match.
        default:
          config: null
          label: null
          name: quilkin.filters.drop.v1alpha1.Drop
        allOf:
        - $ref: '#/definitions/Filter'
      metadataKey:
        description: The key for the metadata to compare against.
        allOf:
        - $ref: '#/definitions/Key'
  Filter:
    description: Filter is the configuration for a single filter
    type: object
    required:
    - name
    properties:
      config: true
      label:
        type:
        - string
        - 'null'
      name:
        type: string
    additionalProperties: false
  Key:
    description: A key in the metadata table.
    type: string
  Value:
    anyOf:
    - type: boolean
    - type: integer
      format: uint64
      minimum: 0.0
    - type: array
      items:
        $ref: '#/definitions/Value'
    - type: string
    - type: array
      items:
        type: integer
        format: uint8
        minimum: 0.0
</code></pre>
<p>View the <a href="services/proxy/filters/../../../../api/quilkin/filters/match/struct.Config.html">Match</a> filter documentation for more details.</p>
<h2 id="metrics-1"><a class="header" href="#metrics-1">Metrics</a></h2>
<ul>
<li><code>quilkin_filter_int_counter{label="packets_matched_total"}</code>
A counter of the total number of packets where the dynamic metadata matches a branch value.</li>
<li><code>quilkin_filter_int_counter{label="packets_fallthrough_total"}</code>
A counter of the total number of packets that are processed by the fallthrough configuration.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pass"><a class="header" href="#pass">Pass</a></h1>
<p>The <code>Pass</code> filter that always passes any packet through it. This is useful in
combination with conditional flow filters like <a href="services/proxy/filters/match.html"><code>Matches</code></a></p>
<h2 id="filter-name-9"><a class="header" href="#filter-name-9">Filter name</a></h2>
<pre><code class="language-text">quilkin.filters.pass.v1alpha1.Pass
</code></pre>
<h2 id="configuration-examples-10"><a class="header" href="#configuration-examples-10">Configuration Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = "
</span>version: v1alpha1
clusters: 
  - endpoints:
    - address: 127.0.0.1:26000
    - address: 127.0.0.1:26001
filters:
  - name: quilkin.filters.capture.v1alpha1.Capture
    config:
      metadataKey: myapp.com/token
      prefix:
        size: 3
        remove: false
  - name: quilkin.filters.match.v1alpha1.Match
    config:
      on_read:
        metadataKey: myapp.com/token
        branches:
          - value: abc
            name: quilkin.filters.pass.v1alpha1.Pass
        fallthrough:
          name: quilkin.filters.drop.v1alpha1.Drop
<span class="boring">";
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.filters.load().len(), 2);
</span><span class="boring">}</span></code></pre></pre>
<h2 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h2>
<p>No defined configuration options.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="timestamp"><a class="header" href="#timestamp">Timestamp</a></h1>
<p>The <code>Timestamp</code> filter accepts a UNIX timestamp from metadata and observes the
duration between that timestamp and now. Mostly useful in combination with other
filters such as <code>Capture</code> to pull timestamp data from packets.</p>
<h2 id="filter-name-10"><a class="header" href="#filter-name-10">Filter name</a></h2>
<pre><code class="language-text">quilkin.filters.timestamp.v1alpha1.Timestamp
</code></pre>
<h2 id="configuration-examples-11"><a class="header" href="#configuration-examples-11">Configuration Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = "
</span>version: v1alpha1
filters:
  - name: quilkin.filters.capture.v1alpha1.Capture
    config:
      metadataKey: example.com/session_duration
      prefix:
        size: 3
        remove: false
  - name: quilkin.filters.timestamp.v1alpha1.Timestamp
    config:
        metadataKey: example.com/session_duration
clusters:
  - endpoints:
    - address: 127.0.0.1:26000
<span class="boring">";
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">}</span></code></pre></pre>
<h2 id="configuration-options-rust-doc-8"><a class="header" href="#configuration-options-rust-doc-8">Configuration Options (<a href="services/proxy/filters/../../../../api/quilkin/filters/timestamp/struct.Config.html">Rust Doc</a>)</a></h2>
<pre><code class="language-yaml">$schema: http://json-schema.org/draft-07/schema#
title: Config
description: Config represents a [self]'s configuration.
type: object
required:
- metadataKey
properties:
  metadataKey:
    description: The metadata key to read the UTC UNIX Timestamp from.
    allOf:
    - $ref: '#/definitions/Key'
definitions:
  Key:
    description: A key in the metadata table.
    type: string
</code></pre>
<h2 id="metrics-2"><a class="header" href="#metrics-2">Metrics</a></h2>
<ul>
<li><code>quilkin_filter_histogram{label="duration"}</code>
A histogram of durations from <code>metadata_key</code> to now in the packet <code>direction</code>.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tokenrouter"><a class="header" href="#tokenrouter">TokenRouter</a></h1>
<p>The <code>TokenRouter</code> filter's job is to provide a mechanism to declare which Endpoints a packet should be sent to.</p>
<p>This Filter provides this functionality by comparing a byte array token found in the
<a href="services/proxy/filters/../filters.html#filter-dynamic-metadata">Filter Dynamic Metadata</a> from a previous Filter, and comparing it to
<a href="services/proxy/filters/../../proxy.html#endpoints">Endpoint's tokens</a>, and sending packets to those Endpoints only if there is a match.</p>
<h2 id="filter-name-11"><a class="header" href="#filter-name-11">Filter name</a></h2>
<pre><code class="language-text">quilkin.filters.token_router.v1alpha1.TokenRouter
</code></pre>
<h2 id="configuration-examples-12"><a class="header" href="#configuration-examples-12">Configuration Examples</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = "
</span>version: v1alpha1
filters:
  - name: quilkin.filters.token_router.v1alpha1.TokenRouter
    config:
        metadataKey: myapp.com/myownkey
clusters:
  - endpoints:
    - address: 127.0.0.1:26000
      metadata:
        quilkin.dev:
          tokens:
            - MXg3aWp5Ng== # Authentication is provided by these ids, and matched against
            - OGdqM3YyaQ== # the value stored in Filter dynamic metadata
    - address: 127.0.0.1:26001
      metadata:
        quilkin.dev:
          tokens:
            - bmt1eTcweA==
<span class="boring">";
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.filters.load().len(), 1);
</span><span class="boring">}</span></code></pre></pre>
<p>View the <a href="services/proxy/filters/capture.html">CaptureBytes</a> filter documentation for more details.</p>
<h2 id="configuration-options-rust-doc-9"><a class="header" href="#configuration-options-rust-doc-9">Configuration Options (<a href="services/proxy/filters/../../../../api/quilkin/filters/token_router/struct.Config.html">Rust Doc</a>)</a></h2>
<pre><code class="language-yaml">$schema: http://json-schema.org/draft-07/schema#
title: Config
type: object
properties:
  metadataKey:
    description: the key to use when retrieving the token from the Filter's dynamic metadata
    default: quilkin.dev/capture
    allOf:
    - $ref: '#/definitions/Key'
definitions:
  Key:
    description: A key in the metadata table.
    type: string
</code></pre>
<h2 id="metrics-3"><a class="header" href="#metrics-3">Metrics</a></h2>
<ul>
<li><code>quilkin_filter_TokenRouter_packets_dropped_total</code>
A counter of the total number of packets that have been dropped. This is also provided with a <code>Reason</code> label, as there
are differing reasons for packets to be dropped:
<ul>
<li><code>NoEndpointMatch</code> - The token provided via the Filter dynamic metadata does not match any Endpoint's tokens.</li>
<li><code>NoTokenFound</code> - No token has been found in the Filter dynamic metadata.</li>
<li><code>InvalidToken</code> - The data found for the token in the Filter dynamic metadata is not of the correct data type
(Vec<u8>)</li>
</ul>
</li>
</ul>
<h2 id="sample-applications"><a class="header" href="#sample-applications">Sample Applications</a></h2>
<h3 id="packet-authentication"><a class="header" href="#packet-authentication">Packet Authentication</a></h3>
<p>In combination with several other filters, the <code>TokenRouter</code> can be utilised as an authentication and access control
mechanism for all incoming packets.</p>
<p>Capturing the authentication token from an incoming packet can be implemented via the <a href="services/proxy/filters/capture.html">CaptureByte</a>
filter, with an example outlined below, or any other filter that populates the configured dynamic metadata key for the
authentication token to reside.</p>
<p>It is assumed that the endpoint tokens that are used for authentication are generated by an external system, are
appropriately cryptographically random and sent to each proxy securely.</p>
<p>For example, a configuration would look like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = "
</span>version: v1alpha1
filters:
  - name: quilkin.filters.capture.v1alpha1.Capture # Capture and remove the authentication token
    config:
      suffix:
          size: 3
          remove: true
  - name: quilkin.filters.token_router.v1alpha1.TokenRouter
clusters:
  - endpoints:
    - address: 127.0.0.1:26000
      metadata:
        quilkin.dev:
          tokens:
            - MXg3aWp5Ng== # Authentication is provided by these ids, and matched against
            - OGdqM3YyaQ== # the value stored in Filter dynamic metadata
    - address: 127.0.0.1:26001
      metadata:
        quilkin.dev:
          tokens:
             - bmt1eTcweA==
<span class="boring">";
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.filters.load().len(), 2);
</span><span class="boring">}</span></code></pre></pre>
<p>On the game client side the <a href="services/proxy/filters/concatenate.html">Concatenate</a> filter could also be used to add authentication
tokens to outgoing packets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-custom-filters"><a class="header" href="#writing-custom-filters">Writing Custom Filters</a></h1>
<blockquote>
<p>The full source code used in this example can be found
in <a href="https://github.com/googleforgames/quilkin/tree/main/examples/quilkin-filter-example"><code>examples/</code></a>.</p>
</blockquote>
<p>Quilkin provides an extensible implementation of <a href="services/proxy/filters/../filters.html">Filters</a> that allows us to
plug in custom implementations to fit our needs.  This document provides an
overview of the API and how we can go about writing our own <a href="services/proxy/filters/../filters.html">Filters</a>. First
we need to create a type and implement two traits for it.</p>
<p>It's not terribly important what the filter in this example does so let's write
a <code>Greet</code> filter that appends <code>Hello</code> to every packet in one direction and
<code>Goodbye</code> to packets in the opposite direction.</p>
<pre><code class="language-rust no_run noplayground">struct Greet;</code></pre>
<blockquote>
<p>As a convention within Quilkin: Filter names are singular, they also tend to
be a verb, rather than an adjective.</p>
<p><strong>Examples</strong></p>
<ul>
<li><strong>Greet</strong> not "Greets"</li>
<li><strong>Compress</strong> not "Compressor".</li>
</ul>
</blockquote>
<h2 id="filter"><a class="header" href="#filter"><code>Filter</code></a></h2>
<p>Represents the actual <a href="services/proxy/filters/../filters.html#built-in-filters">Filter</a> instance in the pipeline. An
implementation provides a <code>read</code> and a <code>write</code> method (both are passthrough
by default) that accepts a context object and returns a response.</p>
<p>Both methods are invoked by the proxy when it consults the <a href="services/proxy/filters/../filters.html#filters-and-filter-chain">filter chain</a>
<code>read</code> is invoked when a packet is received on the local downstream port and
is to be sent to an upstream endpoint while <code>write</code> is invoked in the opposite
direction when a packet is received from an upstream endpoint and is to be
sent to a downstream client.</p>
<pre><code class="language-rust no_run noplayground"><span class="boring">struct Greet;
</span>use quilkin::filters::prelude::*;

/// Appends data to each packet
#[async_trait::async_trait]
impl Filter for Greet {
    async fn read(&amp;self, ctx: &amp;mut ReadContext) -&gt; Result&lt;(), FilterError&gt; {
        ctx.contents.extend_from_slice(b"Hello");
        Ok(())
    }
    async fn write(&amp;self, ctx: &amp;mut WriteContext) -&gt; Result&lt;(), FilterError&gt; {
        ctx.contents.extend_from_slice(b"Goodbye");
        Ok(())
    }
}</code></pre>
<h2 id="staticfilter"><a class="header" href="#staticfilter"><code>StaticFilter</code></a></h2>
<p>Represents metadata needed for your [<code>Filter</code>], most of it has to with defining
configuration, for now we can use <code>()</code> as we have no configuration currently.</p>
<pre><code class="language-rust no_run noplayground"><span class="boring">use quilkin::filters::prelude::*;
</span><span class="boring">struct Greet;
</span><span class="boring">impl Filter for Greet {}
</span>impl StaticFilter for Greet {
    const NAME: &amp;'static str = "greet.v1";
    type Configuration = ();
    type BinaryConfiguration = ();

    fn try_from_config(config: Option&lt;Self::Configuration&gt;) -&gt; Result&lt;Self, CreationError&gt; {
        Ok(Self)
    }
}</code></pre>
<h2 id="running"><a class="header" href="#running">Running</a></h2>
<p>We can run the proxy using <code>Proxy::run</code> function. Let's
add a main function that does that. Quilkin relies on the <a href="https://docs.rs/tokio">Tokio</a> async
runtime, so we need to import that crate and wrap our main function with it.</p>
<p>We can also register custom filters in quilkin using <a href="services/proxy/filters/../../../../api/quilkin/filters/struct.FilterRegistry.html#method.register"><code>FilterRegistry::register</code></a></p>
<p>Add Tokio as a dependency in <code>Cargo.toml</code>.</p>
<pre><code class="language-toml">[dependencies]
quilkin = "0.2.0"
tokio = { version = "1", features = ["full"]}
</code></pre>
<p>Add a main function that starts the proxy.</p>
<pre><code class="language-rust no_run noplayground ignore">// src/main.rs
#[tokio::main]
async fn main() -&gt; quilkin::Result&lt;()&gt; {
    quilkin::filters::FilterRegistry::register(vec![Greet::factory()].into_iter());

    let (_shutdown_tx, shutdown_rx) = quilkin::make_shutdown_channel(quilkin::ShutdownKind::Normal);
    let proxy = quilkin::Proxy::default();
    let config = quilkin::Config::default_non_agent();
    config.filters.store(std::sync::Arc::new(
        quilkin::filters::FilterChain::try_create([quilkin::config::Filter {
            name: Greet::NAME.into(),
            label: None,
            config: None,
        }])?,
    ));
    config.clusters.modify(|map| {
        map.insert_default(
            [quilkin::net::endpoint::Endpoint::new(
                (std::net::Ipv4Addr::LOCALHOST, 4321).into(),
            )]
            .into(),
        )
    });

    proxy
        .run(config.into(), Default::default(), None, shutdown_rx)
        .await
}</code></pre>
<p>Now, let's try out the proxy. The following configuration starts our extended
version of the proxy at port 7777 and forwards all packets to an upstream server
at port 4321.</p>
<pre><code class="language-yaml"># quilkin.yaml
version: v1alpha1
filters:
  - name: greet.v1
clusters:
  - endpoints:
      - address: 127.0.0.1:4321
</code></pre>
<p>Next we to setup our network of services, for this example we're going to use
the <code>netcat</code> tool to spawn a UDP echo server and interactive client for us to
send packets over the wire.</p>
<pre><code class="language-bash"># Start the proxy
cargo run -- &amp;
# Start a UDP listening server on the configured port
nc -lu 127.0.0.1 4321 &amp;
# Start an interactive UDP client that sends packet to the proxy
nc -u 127.0.0.1 7777
</code></pre>
<p>Whatever we pass to the client should now show up with our modification on the
listening server's standard output.  For example typing <code>Quilkin</code> in the client
prints <code>Hello Quilkin</code> on the server.</p>
<h2 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h2>
<p>Let's extend the <code>Greet</code> filter to have a configuration that contains what
greeting to use.</p>
<p>The <a href="https://docs.serde.rs/serde_yaml/index.html">Serde</a> crate is used to describe static YAML configuration in code while
<a href="https://docs.rs/tonic">Tonic</a>/<a href="https://docs.rs/prost">Prost</a> is used to describe dynamic configuration as <a href="https://protobuf.dev">Protobuf</a> messages
when talking to a <a href="services/proxy/filters/../../xds.html">management server</a>.</p>
<h3 id="yaml-configuration"><a class="header" href="#yaml-configuration">YAML Configuration</a></h3>
<p>First let's create the type for our configuration:</p>
<ol>
<li>Add the yaml parsing crates to <code>Cargo.toml</code>:</li>
</ol>
<pre><code class="language-toml"># [dependencies]
serde = "1.0"
serde_yaml = "0.8"
</code></pre>
<ol start="2">
<li>Define a struct representing the config:</li>
</ol>
<pre><code class="language-rust no_run noplayground ignore">// src/main.rs
#[derive(Serialize, Deserialize, Debug, schemars::JsonSchema)]
struct Config {
    greeting: String,
}</code></pre>
<ol start="3">
<li>Update the <code>Greet</code> Filter to take in <code>greeting</code> as a parameter:</li>
</ol>
<pre><code class="language-rust no_run noplayground ignore">// src/main.rs
struct Greet {
    config: Config,
}

#[async_trait::async_trait]
impl Filter for Greet {
    async fn read(&amp;self, ctx: &amp;mut ReadContext) -&gt; Result&lt;(), FilterError&gt; {
        ctx.contents
            .prepend_from_slice(format!("{} ", self.config.greeting).as_bytes());
        Ok(())
    }
    async fn write(&amp;self, ctx: &amp;mut WriteContext) -&gt; Result&lt;(), FilterError&gt; {
        ctx.contents
            .prepend_from_slice(format!("{} ", self.config.greeting).as_bytes());
        Ok(())
    }
}</code></pre>
<h3 id="protobuf-configuration"><a class="header" href="#protobuf-configuration">Protobuf Configuration</a></h3>
<p>Quilkin comes with out-of-the-box support for xDS management, and as such needs
to communicate filter configuration over <a href="https://protobuf.dev">Protobuf</a> with management servers and
clients to synchronise state across the network. So let's add the binary version
of our <code>Greet</code> configuration.</p>
<ol>
<li>Add the proto parsing crates to <code>Cargo.toml</code>:</li>
</ol>
<pre><code class="language-toml">[dependencies]
# ...
tonic = "0.5.0"
prost = "0.7"
prost-types = "0.7"
</code></pre>
<ol start="2">
<li>Create a <a href="https://protobuf.dev">Protobuf</a> equivalent of our YAML configuration.</li>
</ol>
<pre><code class="language-plaintext no_run noplayground ignore">// src/greet.proto
syntax = "proto3";

package greet;

message Greet {
  string greeting = 1;
}
</code></pre>
<ol start="3">
<li>Generate Rust code from the proto file:</li>
</ol>
<h3 id="generated---recommended"><a class="header" href="#generated---recommended">Generated - Recommended</a></h3>
<p>Use something like <a href="https://github.com/EmbarkStudios/proto-gen">proto-gen</a> to generate Rust code for the protobuf.</p>
<p>At that point it is just normal rust code and can be included from where you placed the generated code, eg. <code>generated</code>.</p>
<pre><code class="language-rust no_run noplayground ignore">mod generated;
use generated::greet as proto;</code></pre>
<h3 id="at-build-time"><a class="header" href="#at-build-time">At build time</a></h3>
<p>There are a few ways to generate <a href="https://docs.rs/prost">Prost</a> code from proto, we will use the <a href="https://docs.rs/prost-build/0.7.0/prost_build/">prost_build</a> crate in this example.</p>
<p>Add the following required crates to <code>Cargo.toml</code>, and then add a
<a href="https://doc.rust-lang.org/cargo/reference/build-scripts.html">build script</a> to generate the following Rust code
during compilation:</p>
<pre><code class="language-toml"># [dependencies]
bytes = "1.0"

# [build-dependencies]
prost-build = "0.7"
</code></pre>
<pre><code class="language-rust no_run noplayground ignore">// src/build.rs
fn main() {
    // Remove if you already have `protoc` installed in your system.
    std::env::set_var("PROTOC", protobuf_src::protoc());

    prost_build::compile_protos(&amp;["src/greet.proto"], &amp;["src/"]).unwrap();
}</code></pre>
<p>To include the generated code, we'll use [<code>tonic::include_proto</code>].</p>
<pre><code class="language-rust no_run noplayground ignore">// src/main.rs
#[allow(warnings, clippy::all)]
// ANCHOR: include_proto
mod proto {
    tonic::include_proto!("greet");
}</code></pre>
<ol start="4">
<li>Then we just need to implement <a href="https://doc.rust-lang.org/std/convert/trait.TryFrom.html">std::convert::TryFrom</a> for converting the protobuf message to
equivalent configuration.</li>
</ol>
<pre><code class="language-rust no_run noplayground ignore">// src/main.rs
impl TryFrom&lt;proto::Greet&gt; for Config {
    type Error = ConvertProtoConfigError;

    fn try_from(p: proto::Greet) -&gt; Result&lt;Self, Self::Error&gt; {
        Ok(Self {
            greeting: p.greeting,
        })
    }
}

impl From&lt;Config&gt; for proto::Greet {
    fn from(config: Config) -&gt; Self {
        Self {
            greeting: config.greeting,
        }
    }
}</code></pre>
<p>Now, let's update <code>Greet</code>'s <code>StaticFilter</code> implementation to use the two
configurations.</p>
<pre><code class="language-rust no_run noplayground ignore">// src/main.rs
use quilkin::filters::StaticFilter;

impl StaticFilter for Greet {
    const NAME: &amp;'static str = "greet.v1";
    type Configuration = Config;
    type BinaryConfiguration = proto::Greet;

    fn try_from_config(config: Option&lt;Self::Configuration&gt;) -&gt; Result&lt;Self, CreationError&gt; {
        Ok(Self {
            config: Self::ensure_config_exists(config)?,
        })
    }
}</code></pre>
<p>That's it! With these changes we have wired up static configuration for our
filter. Try it out with the following configuration:</p>
<pre><code class="language-yaml"># quilkin.yaml
version: v1alpha1
port: 7001
filters:
- name: greet.v1
  config:
    greeting: Hey
endpoints:
- address: 127.0.0.1:4321
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quilkin-control-message-protocol-qcmp"><a class="header" href="#quilkin-control-message-protocol-qcmp">Quilkin Control Message Protocol (QCMP)</a></h1>
<div class="table-wrapper"><table><thead><tr><th>services</th><th>ports</th><th>Protocol</th></tr></thead><tbody>
<tr><td>QCMP</td><td>7600</td><td>UDP AND TCP (IPv4 OR IPv6)</td></tr>
</tbody></table>
</div>
<p>In addition to the TCP based administration API, Quilkin provides a meta API
over UDP and TCP. The purpose of this API is to provide meta operations that can
be used by untrusted clients. Currently the API is focuses on providing pings
for latency measurement but that may change overtime as new features are added.</p>
<h2 id="ping"><a class="header" href="#ping">Ping</a></h2>
<p>The main functionality currently in QCMP is pinging, measuring the latency from
one service to another over UDP. You can also measure the distance locally using
the <code>quilkin qcmp ping</code> command.</p>
<pre><code>quilkin qcmp ping 127.0.0.1:7600
</code></pre>
<h2 id="protocol-data-unit"><a class="header" href="#protocol-data-unit">Protocol Data Unit</a></h2>
<p>The following is a <a href="https://kaitai.io/">Kaitai Struct</a> configuration of the protocol data unit
accepted by Quilkin proxies.</p>
<pre><code class="language-yaml">meta:
  id: quilkin_packet
  endian: be
seq:
  - id: magic_header
    contents: "QLKN"
  - id: protocol_version
    type: u1
  - id: packet_type
    type: u1
  - id: packet_length
    type: u2
  - id: packet
    size: packet_length
    type:
      switch-on: packet_type
      cases:
        0: ping_packet
        1: ping_reply_packet

types:
  ping_packet:
    doc: |
        Sent by a client to a proxy containing the time when the client sent the
        packet along with a unique nonce. The timestamp should be a UTC unix
        timestamp in **nanoseconds**.
    seq:
      - id: nonce
        type: u1
      - id: client_sent_timestamp
        type: u8

  ping_reply_packet:
    doc: |
        A reply from a proxy containing the ping's nonce, the client sent time,
        the server's receive time, and the server's sent time. The timestamps
        should be UTC unix timestamps in **nanoseconds**.
    seq:
      - id: nonce
        type: u1
      - id: client_sent_timestamp
        type: u8
      - id: server_receive_timestamp
        type: u8
      - id: server_sent_timestamp
        type: u8
</code></pre>
<h2 id="datacenter-latency"><a class="header" href="#datacenter-latency">Datacenter Latency</a></h2>
<p>In addition to being able to ping Quilkin to get the latency between the client
and proxy. In order to allow clients to send information to services like a
matchmaker about which datacentre they are closest to, Quilkin also includes
the ability to get a proxy's latency to each of its connected datacentres.</p>
<blockquote>
<p>Note: This requires a multi-cluster relay setup, as when you set up proxies
in the same cluster as gameservers, this measurement is redundant.</p>
</blockquote>
<p>All that is required to set this up is to provide an ICAO code to the agent in
the gameserver cluster. (E.g. through the environment variable <code>ICAO_CODE</code>).
No further setup is required. <strong>You can use duplicate ICAO codes</strong>, Quilkin will
choose the best result amongst the duplicates to return. Quilkin assumes that
multiple of the same ICAO code refer to the same phyiscal datacentre, so latency
between them should negible.</p>
<blockquote>
<p>Why ICAO? ICAO is an international standard for airport codes, airport codes
are an easy human readable code that makes it easy to use geo-visualisations
in tools like Grafana, and easily allows grouping. IATA codes only cover
major airports, ICAO codes cover practically every airport making them easy to
more accurately represent the location of any datacentre.</p>
</blockquote>
<h3 id="api-and-schema"><a class="header" href="#api-and-schema">API And Schema</a></h3>
<p>Currently the datacentre latency can be retrieved by sending a <code>GET /</code> HTTP
request to the QCMP port.</p>
<p>The returned data is a JSON object with each key being the ICAO code for the
datacentre, and the value being the latency in nanoseconds.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proxy-metrics"><a class="header" href="#proxy-metrics">Proxy Metrics</a></h1>
<p>The following are metrics that Quilkin provides while in Proxy Mode.</p>
<h1 id="asn-maxmind-information"><a class="header" href="#asn-maxmind-information">ASN Maxmind Information</a></h1>
<p>If Quilkin is provided a a MaxmindDB GeoIP database, Quilkin will log the
following information in the <code>maxmind information</code> log, as well as populate
the following fields in any metrics with matching labels.</p>
<div class="table-wrapper"><table><thead><tr><th>Field</th><th>Description</th></tr></thead><tbody>
<tr><td><code>asn</code></td><td>ASN Number</td></tr>
<tr><td><code>organization</code></td><td>The organisation responsible for the ASN</td></tr>
<tr><td><code>country_code</code></td><td>The corresponding country code</td></tr>
<tr><td><code>ip_prefix</code></td><td>The IP prefix CIDR address</td></tr>
<tr><td><code>prefix_entity</code></td><td>The name of the entity for the prefix address</td></tr>
<tr><td><code>prefix_name</code></td><td>The name of the prefix address</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Maxmind databases often require a licence and/or fee, so they aren't included
by default with Quilkin.</p>
</blockquote>
<h2 id="general-metrics"><a class="header" href="#general-metrics">General Metrics</a></h2>
<p>The proxy exposes the following general metrics:</p>
<ul>
<li>
<p><code>quilkin_packets_processing_duration_seconds{event, asn, ip_prefix}</code> (Histogram)</p>
<p>The total duration of time in seconds that it took to process a packet.</p>
<ul>
<li>The <code>event</code> label is either:
<ul>
<li><code>read</code>: when the proxy receives data from a downstream connection on the listening port.</li>
<li><code>write</code>: when the proxy sends data to a downstream connection via the listening port.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>quilkin_packets_dropped_total{reason, asn, ip_prefix}</code> (Counter)</p>
<p>The total number of packets (not associated with any session) that were dropped by proxy.
Not that packets reflected by this metric were dropped at an earlier stage before they were associated with any session. For session based metrics, see the list of <a href="services/proxy/metrics.html#session-metrics">session metrics</a> instead.</p>
<ul>
<li><code>reason = NoConfiguredEndpoints</code>
<ul>
<li><code>NoConfiguredEndpoints</code>: No upstream endpoints were available to send the packet to. This can occur e.g if the endpoints cluster was scaled down to zero and the proxy is configured via a control plane.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>quilkin_cluster_active</code></p>
<p>The number of currently active clusters.</p>
</li>
<li>
<p><code>quilkin_cluster_active_endpoints</code></p>
<p>The number of currently active upstream endpoints. Note that this tracks the number of endpoints that the proxy
knows of rather than those that it is connected to (see <a href="services/proxy/metrics.html#session-metrics">Session Metrics</a> instead for those)</p>
</li>
<li>
<p><code>quilkin_bytes_total{event, asn, ip_prefix}</code></p>
<p>The total number of bytes sent or recieved</p>
<ul>
<li>The <code>event</code> label is either:
<ul>
<li><code>read</code>: when the proxy receives data from a downstream connection on the listening port.</li>
<li><code>write</code>: when the proxy sends data to a downstream connection via the listening port.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>quilkin_packets_total{event, asn, ip_prefix}</code></p>
<p>The total number of packets sent or recieved.</p>
<ul>
<li>The <code>event</code> label is either:
<ul>
<li><code>read</code>: when the proxy receives data from a downstream connection on the listening port.</li>
<li><code>write</code>: when the proxy sends data to a downstream connection via the listening port.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><code>quilkin_packet_jitter{event, asn, ip_prefix}</code></p>
<p>The time between receiving new packets.</p>
</li>
<li>
<p><code>quilkin_errors_total{event, asn, ip_prefix}</code></p>
<p>The total number of errors encountered while reading a packet from the upstream endpoint.</p>
</li>
</ul>
<h2 id="session-metrics"><a class="header" href="#session-metrics">Session Metrics</a></h2>
<p>The proxy exposes the following metrics around sessions:</p>
<ul>
<li>
<p><code>quilkin_session_active{asn, organization, country_code, ip_prefix, prefix_entity, prefix_name}</code></p>
<p>The number of currently active sessions. If a maxmind database has been
provided, the labels are populated:</p>
<ul>
<li>The <code>asn</code> label is the <a href="https://en.wikipedia.org/wiki/Autonomous_system_(Internet)">ASN</a> number of the connecting
client.</li>
<li>The <code>ip_prefix</code>label is the IP prefix of the connecting client.</li>
</ul>
</li>
<li>
<p><code>quilkin_session_duration_secs</code> (Histogram)</p>
<p>A histogram over how long sessions lasted before they were torn down. Note that, by definition, active sessions are not included in this metric.</p>
</li>
<li>
<p><code>quilkin_session_total</code> (Counter)</p>
<p>The total number of sessions that have been created.</p>
</li>
</ul>
<h2 id="filter-metrics"><a class="header" href="#filter-metrics">Filter Metrics</a></h2>
<p>Quilkin's filters use a set of generic metric keys, to make it easier to build visualisations that can account for
a dynamic set of filters that can be added, removed, or updated at runtime with different configurations. All of
these metrics share a common set of labels.</p>
<div class="table-wrapper"><table><thead><tr><th>Label</th><th>Description</th></tr></thead><tbody>
<tr><td><code>id</code></td><td>The ID of the filter that used the metric.</td></tr>
<tr><td><code>label</code></td><td>The name of the metric being measured.</td></tr>
<tr><td><code>help</code></td><td>The description of the filter metric.</td></tr>
<tr><td><code>direction</code></td><td>The direction of packet flow (e.g. read/write).</td></tr>
</tbody></table>
</div>
<ul>
<li>
<p><code>quilkin_filter_int_counter{id, label, help, direction}</code>
Generic filter counter, see help label for more specific info.</p>
</li>
<li>
<p><code>quilkin_filter_histogram{id, label, help, direction, shared_metadata_1}</code>
generic filter histogram, see help label for more specific info.</p>
</li>
<li>
<p><code>quilkin_filter_read_duration_seconds{filter}</code></p>
<p>The duration it took for a <code>filter</code>'s <code>read</code> implementation to execute.</p>
<ul>
<li>The<code>filter</code> label is the name of the filter being executed.</li>
</ul>
</li>
<li>
<p><code>quilkin_filter_write_duration_seconds{filter}</code></p>
<p>The duration it took for a <code>filter</code>'s <code>write</code> implementation to execute.</p>
<ul>
<li>The <code>filter</code> label is the name of the filter being executed.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xds-control-plane"><a class="header" href="#xds-control-plane">xDS Control Plane</a></h1>
<div class="table-wrapper"><table><thead><tr><th>services</th><th>ports</th><th>Protocol</th></tr></thead><tbody>
<tr><td>xDS</td><td>7800</td><td>gRPC (IPv4 OR IPv6)</td></tr>
</tbody></table>
</div>
<p>For single-cluster integration, Quilkin provides a <code>manage</code> service, that can be
used with a number of configuration discovery providers to provide cluster
configuration multiple <a href="services/./proxy.html"><code>proxy</code>s</a>. With each provider automating the
complexity of a full xDS management control plane via integrations with popular
projects and common architecture patterns.</p>
<p>To view all the providers and options for the <code>manage</code> subcommand, run:</p>
<pre><code class="language-shell">$ quilkin manage --help
Runs Quilkin as a xDS management server, using `provider` as a configuration source

Usage: quilkin manage [OPTIONS] &lt;COMMAND&gt;

Commands:
  agones  Watches Agones' game server CRDs for `Allocated` game server endpoints, and for a `ConfigMap` that specifies the filter configuration
  file    Watches for changes to the file located at `path`
  help    Print this message or the help of the given subcommand(s)

Options:
  -r, --relay &lt;RELAY&gt;        One or more `quilkin relay` endpoints to push configuration changes to [env: QUILKIN_MANAGEMENT_SERVER=]
  -p, --port &lt;PORT&gt;          The TCP port to listen to, to serve discovery responses [env: QUILKIN_PORT=] [default: 7800]
      --region &lt;REGION&gt;      The `region` to set in the cluster map for any provider endpoints discovered [env: QUILKIN_REGION=]
      --zone &lt;ZONE&gt;          The `zone` in the `region` to set in the cluster map for any provider endpoints discovered [env: QUILKIN_ZONE=]
      --sub-zone &lt;SUB_ZONE&gt;  The `sub_zone` in the `zone` in the `region` to set in the cluster map for any provider endpoints discovered [env: QUILKIN_SUB_ZONE=]
  -h, --help                 Print help
</code></pre>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>In addition to static configuration provided upon startup, a Quiklin proxy's configuration can also be updated at runtime. The proxy can be configured on startup to talk to a set of management servers which provide it with updates throughout its lifecycle.</p>
<p>Communication between the proxy and management server uses the <a href="https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol#xds-rest-and-grpc-protocol">xDS gRPC protocol</a>, similar to an <a href="https://www.envoyproxy.io/docs/envoy/latest/">envoy proxy</a>. xDS is one of the standard configuration mechanisms for software proxies and as a result, Quilkin can be setup to discover configuration resources from any API compatible server. Also, given that the protocol is <a href="https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol#the-xds-transport-protocol">well specified</a>, it is similarly straight-forward to implement a custom server to suit any deployment's needs.</p>
<p>As described within the <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/dynamic_configuration">xDS-api</a> documentation, the xDS API comprises a set of resource discovery APIs, each serving a specific set of configuration resource types, while the protocol itself comes in several <a href="https://www.envoyproxy.io/docs/envoy/latest/api-docs/xds_protocol#variants-of-the-xds-transport-protocol">variants</a>.
Quilkin implements the <strong>Aggregated Discovery Service (ADS)</strong> <em>State of the World (SotW)</em> variant with gRPC.</p>
<h2 id="supported-apis"><a class="header" href="#supported-apis">Supported APIs</a></h2>
<p>Since the range of resources configurable by the xDS API extends that of Quilkin's domain (i.e being UDP based, Quilkin does not have a need for HTTP/TCP resources), only a subset of the API is supported. The following lists these relevant parts and any limitation to the provided support as a result:</p>
<ul>
<li>
<p><strong>Cluster Discovery Service <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/dynamic_configuration#cds">(CDS)</a></strong>: Provides information about known clusters and their membership information.</p>
<ul>
<li>The proxy uses these resources to discover clusters and their endpoints.</li>
<li>While cluster topology information like <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/base.proto#config-core-v3-locality">locality</a> can be provided in the configuration, the proxy currently does not use this information (support may be included in the future however).</li>
<li>Any <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#enum-config-cluster-v3-cluster-lbpolicy">load balancing information</a> included in this resource is ignored. For load balancing, use <a href="services/./proxy/filters.html">Quilkin filters</a> instead.</li>
<li>Only <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/cluster/v3/cluster.proto#enum-config-cluster-v3-cluster-discoverytype">cluster discovery type</a> <code>STATIC</code> and <code>EDS</code> is supported. Configuration including other discovery types e.g <code>LOGICAL_DNS</code> is rejected.</li>
</ul>
</li>
<li>
<p><strong>Endpoint Discovery Service <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/dynamic_configuration#eds">(EDS)</a></strong>: Provides information about endpoints.</p>
<ul>
<li>The proxy uses these resources to discover information about endpoints like their IP addresses.</li>
<li>Endpoints may provide <a href="services/proxy.html#endpoint-metadata">Endpoint Metadata</a> via the <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/base.proto#envoy-v3-api-msg-config-core-v3-metadata">metadata</a> field. These metadata will be visible to filters as part of the corresponding endpoints information when processing packets.</li>
<li>Only <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/core/v3/address.proto#config-core-v3-address">socket addresses</a> are supported on an endpoint's address configuration - i.e an IP address and port number combination. Configuration including any other type of addressing e.g named pipes will be rejected.</li>
<li>Any <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/endpoint/v3/endpoint.proto#config-endpoint-v3-clusterloadassignment-policy">load balancing information</a> included in this resource is ignored. For load balancing, use <a href="services/./proxy/filters.html">Quilkin filters</a> instead.</li>
</ul>
</li>
<li>
<p><strong>Listener Discovery Service <a href="https://www.envoyproxy.io/docs/envoy/latest/intro/arch_overview/operations/dynamic_configuration#lds">(LDS)</a></strong>: Provides information about <a href="services/./proxy/filters.html">Filters and Filter Chains</a>.</p>
<ul>
<li>Only the <code>name</code> and <code>filter_chains</code> fields in the <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/listener/v3/listener.proto#config-listener-v3-listener">Listener resource</a> are used by the proxy. The rest are ignored.</li>
<li>Since Quilkin only uses one filter chain per proxy, at most one filter chain can be provided in the resource. Otherwise the configuration is rejected.</li>
<li>Only the list of <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/listener/v3/listener_components.proto#envoy-v3-api-msg-config-listener-v3-filter">filters</a> specified in the <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/config/listener/v3/listener_components.proto#config-listener-v3-filterchain">filter chain</a> is used by the proxy - i.e other fields like <code>filter_chain_match</code> are ignored. This list also specifies the order that the corresponding filter chain will be constructed.</li>
<li>gRPC proto configuration for Quilkin's built-in filters <a href="https://github.com/googleforgames/quilkin/tree/main/proto/quilkin/filters">can be found here</a>. They are equivalent to the filter's static configuration.</li>
</ul>
</li>
</ul>
<h2 id="connecting-to-an-xds-management-server"><a class="header" href="#connecting-to-an-xds-management-server">Connecting to an xDS management server</a></h2>
<p>Connecting a Quilkin proxy to an xDS management server can be implemented via providing one or more URLs to
the <code>management_servers</code> <a href="services/../../api/quilkin/struct.Proxy.html#structfield.management_server">command line</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="xds-metrics"><a class="header" href="#xds-metrics">xDS Metrics</a></h1>
<h2 id="proxy-mode"><a class="header" href="#proxy-mode">Proxy Mode</a></h2>
<p>Quilkin exposes the following metrics around the management servers and its resources when running as a
<a href="services/xds/../proxy.html">UDP Proxy</a>:</p>
<ul>
<li>
<p><code>quilkin_xds_connected_state</code> (Gauge)</p>
<p>A boolean that indicates whether or not the proxy is currently connected to a management server. A value <code>1</code> means that the proxy is connected while <code>0</code> means that it is not connected to any server at that point in time.</p>
</li>
<li>
<p><code>quilkin_xds_update_attempt_total</code> (Counter)</p>
<p>The total number of attempts made by a management server to configure the proxy. This is equivalent to the total number of configuration updates received by the proxy from a management server.</p>
</li>
<li>
<p><code>quilkin_xds_update_success_total</code> (Counter)</p>
<p>The total number of successful attempts made by a management server to configure the proxy. This is equivalent to the total number of configuration updates received by the proxy from a management server and was successfully applied by the proxy.</p>
</li>
<li>
<p><code>quilkin_xds_update_failure_total</code> (Counter)</p>
<p>The total number of unsuccessful attempts made by a management server to configure the proxy. This is equivalent to the total number of configuration updates received by the proxy from a management server and was rejected by the proxy (e.g due to a bad/inconsistent configuration).</p>
</li>
<li>
<p><code>quilkin_xds_requests_total</code> (Counter)</p>
<p>The total number of <a href="https://www.envoyproxy.io/docs/envoy/latest/api-v3/service/discovery/v3/discovery.proto.html#service-discovery-v3-discoveryrequest">DiscoveryRequest</a>s made by the proxy to management servers. This tracks messages flowing in the direction from the proxy to the management server.</p>
</li>
</ul>
<h2 id="xds-provider-mode"><a class="header" href="#xds-provider-mode">xDS Provider Mode</a></h2>
<p>The following metrics are exposed when Quilkin is running as an <a href="services/xds/../xds.html">xDS provider</a>.</p>
<ul>
<li>
<p><code>quilkin_management_server_connected_proxies</code> (Gauge)</p>
<p>The number of proxies currently connected to the server.</p>
</li>
<li>
<p><code>quilkin_management_server_discovery_requests_total{request_type}</code> (Counter)</p>
<p>The total number of xDS Discovery requests received across all proxies.</p>
<ul>
<li><code>request_type</code> = <code>type.googleapis.com/envoy.config.cluster.v3.Cluster</code> | <code>type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment</code> | <code>type.googleapis.com/envoy.config.listener.v3.Listener</code>
Type URL of the requested resource</li>
</ul>
</li>
<li>
<p><code>quilkin_management_server_discovery_responses_total</code> (Counter)</p>
<p>The total number of xDS Discovery responses sent back across all proxies in response to Discovery Requests.
Each Discovery response sent corresponds to a configuration update for some proxy.</p>
<ul>
<li><code>request_type</code> = <code>type.googleapis.com/envoy.config.cluster.v3.Cluster</code> | <code>type.googleapis.com/envoy.config.endpoint.v3.ClusterLoadAssignment</code> | <code>type.googleapis.com/envoy.config.listener.v3.Listener</code>
Type URL of the requested resource</li>
</ul>
</li>
<li>
<p><code>quilkin_management_server_endpoints_total</code> (Gauge)</p>
<p>The number of active endpoints discovered by the server. The number of active endpoints
correlates with the size of the cluster configuration update sent to proxies.</p>
</li>
<li>
<p><code>quilkin_management_server_snapshot_generation_errors_total</code> (Counter)</p>
<p>The total number of errors encountered while generating a configuration snapshot update for a proxy.</p>
</li>
<li>
<p><code>quilkin_management_server_snapshots_generated_total</code> (Counter)</p>
<p>The total number of configuration snapshot generated across all proxies. A snapshot corresponds
to a point in time view of a proxy's configuration. However it does not necessarily correspond
to a proxy update - a proxy only gets the latest snapshot so it might miss intermediate
snapshots if it lags behind.</p>
</li>
<li>
<p><code>quilkin_management_server_snapshots_cache_size</code> (Gauge)</p>
<p>The current number of snapshots in the in-memory snapshot cache. This corresponds 1-1 to
proxies that connect to the server. However the number may be slightly higher than the number
of connected proxies since snapshots for disconnected proxies are only periodically cleared
from the cache.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="agones-xds-provider"><a class="header" href="#agones-xds-provider">Agones xDS Provider</a></h1>
<p>The <a href="https://agones.dev">Agones</a> xDS Provider is built to simplify Quilkin integration with Agones
game server hosting on top of <a href="https://kubernetes.io">Kubernetes</a>.</p>
<p>This provider watches for changes in Agones
<a href="https://agones.dev/site/docs/getting-started/create-gameserver/"><code>GameServer</code> resources</a> in a cluster, and
utilises that information to provide <a href="services/xds/providers/../../proxy.html#endpoints">Endpoint</a> information to connected Quilkin proxies.</p>
<p>To view all the options for the agones provider subcommand, run:</p>
<pre><code class="language-shell">$ quilkin manage agones --help
Watches Agones' game server CRDs for `Allocated` game server endpoints, and for a `ConfigMap` that specifies the filter configuration

Usage: quilkin manage agones [OPTIONS]

Options:
  -c, --config-namespace &lt;CONFIG_NAMESPACE&gt;
          The namespace under which the configmap is stored [env: QUILKIN_AGONES_CONFIG_NAMESPACE=]
  -g, --gameservers-namespace &lt;GAMESERVERS_NAMESPACE&gt;
          The namespace under which the game servers run [env: QUILKIN_AGONES_GAMESERVERS_NAMESPACE=] [default: default]
  -h, --help
          Print help
</code></pre>
<blockquote>
<p>Currently, the Agones provider can only discover resources within the cluster it is running in.</p>
</blockquote>
<h2 id="endpoint-configuration"><a class="header" href="#endpoint-configuration">Endpoint Configuration</a></h2>
<p>This provider watches the Kubernetes clusters for <code>Allocated</code>
<a href="https://agones.dev/site/docs/reference/gameserver/#gameserver-state-diagram">Agones GameServers</a>
and exposes their IP address and Port as <a href="services/xds/providers/../../proxy.html#endpoints">Endpoints</a> to any connected Quilkin proxies.</p>
<blockquote>
<p>Since an Agones GameServer can have multiple ports exposed, if multiple ports are in
use, the server will pick the first port in the port list.</p>
</blockquote>
<p>By default the Agones xDS provider will look in the <code>default</code> namespace for any <code>GameServer</code> resources, but it can be
configured via the <code>--gameservers-namespace</code> argument.</p>
<h3 id="access-tokens"><a class="header" href="#access-tokens">Access Tokens</a></h3>
<p>The set of <a href="services/xds/providers/../../proxy.html#specialist-endpoint-metadata">access tokens</a> for the associated Endpoint can be
set by adding a comma separated standard base64 encoded strings. This must be added under an annotation
<code>quilkin.dev/tokens</code> in the
<a href="https://agones.dev/site/docs/reference/agones_crd_api_reference/#agones.dev/v1.GameServer">GameServer</a>'s metadata.</p>
<p>For example:</p>
<pre><code class="language-yaml">annotations:
   # Sets two tokens for the corresponding endpoint with values 1x7ijy6 and 8gj3v2i respectively.
   quilkin.dev/tokens: MXg3aWp5Ng==,OGdqM3YyaQ==
</code></pre>
<h2 id="filter-configuration"><a class="header" href="#filter-configuration">Filter Configuration</a></h2>
<p>The Agones provider watches for a singular <a href="https://kubernetes.io/docs/concepts/configuration/configmap/"><code>ConfigMap</code></a>
that has the label of <code>quilkin.dev/configmap: "true"</code>, and any changes that happen to it, and use its contents to
send <a href="services/xds/providers/../../../services/proxy/filters.html">Filter</a> configuration to any connected Quilkin proxies.</p>
<p>The <code>ConfigMap</code> contents should be a valid Quilkin <a href="services/xds/providers/../../../services/proxy/configuration.html">file configuration</a>, but with no
Endpoint data.</p>
<p>For example:</p>
<pre><code class="language-yaml">apiVersion: v1
kind: ConfigMap
metadata:
  name: quilkin-xds-filter-config
  labels:
    quilkin.dev/configmap: "true"
data:
  quilkin.yaml: |
    version: v1alpha1
    filters:
      - name: quilkin.filters.capture.v1alpha1.Capture
        config:
          suffix:
            size: 3
            remove: true
      - name: quilkin.filters.token_router.v1alpha1.TokenRouter
</code></pre>
<p>By default the Agones xDS provider will look in the <code>default</code> namespace for this <code>ConfigMap</code>, but it can be
configured via the <code>--config-namespace</code> argument.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>As an example, the following runs the server with subcommnad <code>manage agones</code> against a cluster (using default
kubeconfig authentication) where Quilkin pods run in the <code>quilkin</code> namespace and <code>GameServer</code> pods run in the
<code>gameservers</code> namespace:</p>
<pre><code class="language-sh">quilkin manage agones --config-namespace quilkin --gameservers-namespace gameservers
</code></pre>
<p>For a full referenmce of deploying this provider in a Kubernetes cluster, with appropriate <a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployments</a>, <a href="https://kubernetes.io/docs/concepts/services-networking/service/">Services</a>,
and <a href="https://kubernetes.io/docs/reference/access-authn-authz/rbac/">RBAC</a> Rules, there is an <a href="https://github.com/googleforgames/quilkin/tree/main/examples/agones-xonotic-xds">Agones, xDS and Xonotic example</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="filesystem-xds-provider"><a class="header" href="#filesystem-xds-provider">Filesystem xDS Provider</a></h1>
<p>The filesystem provider watches a configuration file on disk and sends updates to proxies whenever that file changes.</p>
<p>To view all the options for the file provider subcommand, run:</p>
<pre><code class="language-shell">$ quilkin manage agones --help
Watches for changes to the file located at `path`

Usage: quilkin manage file &lt;PATH&gt;

Arguments:
  &lt;PATH&gt;  The path to the source config [env: QUILKIN_FS_PATH=]

Options:
  -h, --help  Print help
</code></pre>
<p>For example:</p>
<pre><code class="language-sh">quilkin manage file quilkin.yaml
</code></pre>
<p>We run this on port 1800, in this example, in case you are running this locally, and the
default port is taken up by an existing Quilkin proxy.</p>
<p>After running this command, any proxy that connects to port 18000 will receive updates as configured in <code>config.yaml</code>
file.</p>
<p>You can find the configuration file schema in <a href="services/xds/providers/../../../services/proxy/configuration.html">Configuration File</a>.</p>
<p>Example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let yaml = "
</span>version: v1alpha1
filters:
  - name: quilkin.filters.debug.v1alpha1.Debug
    config:
      id: hello
clusters:
  - endpoints:
     - address: 123.0.0.1:29
       metadata:
         'quilkin.dev':
           tokens:
             - 'MXg3aWp5Ng=='
<span class="boring">";
</span><span class="boring">let config = quilkin::config::Config::from_reader(yaml.as_bytes()).unwrap();
</span><span class="boring">assert_eq!(config.filters.load().len(), 1);
</span><span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-plane-relay"><a class="header" href="#control-plane-relay">Control Plane Relay</a></h1>
<div class="table-wrapper"><table><thead><tr><th>services</th><th>ports</th><th>Protocol</th></tr></thead><tbody>
<tr><td>ADS</td><td>7800</td><td>gRPC(IPv4 OR IPv6)</td></tr>
<tr><td>CPDS</td><td>7900</td><td>gRPC(IPv4 OR IPv6)</td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Note:</strong> This service is currently in active experimentation and development
so there may be bugs which cause it to be unusable  for production, as always
all bug reports are welcome and appreciated.</p>
</blockquote>
<p>For multi-cluster integration, Quilkin provides a <code>relay</code> service, that can be
used with a multiple <a href="services/./xds.html">control plane</a> services in different clusters to
provide a unified "Aggregated Discovery Service" endpoint for <a href="services/./proxy.html">proxy</a>
services.</p>
<p>To connect to a control plane to a relay, add the <code>--relay</code> flag to your control
plane with the address of the relay. Then to connect a proxy service to the
relay's ADS endpoint, you use the same <code>--management-server</code> argument for
connecting to control planes.</p>
<p>To view all options for the <code>relay</code> subcommand, run:</p>
<pre><code class="language-shell">$ quilkin relay --help
Runs Quilkin as a relay service that runs a Manager Discovery Service (mDS) for accepting cluster and configuration information from xDS management services, and exposing it as a single merged xDS service for proxy services

Usage: quilkin relay [OPTIONS] [COMMAND]

Commands:
  agones  Watches Agones' game server CRDs for `Allocated` game server endpoints, and for a `ConfigMap` that specifies the filter configuration
  file    Watches for changes to the file located at `path`
  help    Print this message or the help of the given subcommand(s)

Options:
  -m, --mds-port &lt;MDS_PORT&gt;
          Port for mDS service [env: QUILKIN_MDS_PORT=] [default: 7900]
  -x, --xds-port &lt;XDS_PORT&gt;
          Port for xDS management_server service [env: QUILKIN_PORT=] [default: 7800]
      --idle-request-interval-secs &lt;IDLE_REQUEST_INTERVAL_SECS&gt;
          The interval in seconds at which the relay will send a discovery request to an management server after receiving no updates [env: QUILKIN_IDLE_REQUEST_INTERVAL_SECS=]
  -h, --help
          Print help
</code></pre>
<blockquote>
<p>Each sub-control planes (<code>file</code>, <code>agones</code>, etc) matches the <code>quilkin manage</code> providers capabilities.
Have a look at each of the <a href="services/../services/xds.html">Control Plane &gt; Providers</a> documentation for integration details.</p>
</blockquote>
<h2 id="quickstart"><a class="header" href="#quickstart">Quickstart</a></h2>
<p>To get started with the relay service we need to start the relay service, and
then setup our configuration source. For this we're going to the built-in
relay client in the control plane service to forward information to the relay.
For this demo we'll use the file provider for the control plane, but this
example works with any configuration provider.</p>
<pre><code class="language-yaml"># quilkin.yaml
version: v1alpha1
clusters:
  - endpoints:
    - address: 127.0.0.1:8888
</code></pre>
<p>To start the relay, run the <code>relay</code> command:</p>
<pre><code>quilkin relay 
</code></pre>
<p>To spawn the control plane and have the control plane send its configuration,
we need to run the <code>manage</code> command with the <code>--relay</code> flag with the address
of the relay of the relay server we just spawned which is at port <code>7900</code> by
default. We're also going to set <code>--admin-address</code> and <code>--port</code> flags to avoid
port collision with the relay's admin and xds endpoints.</p>
<pre><code>quilkin --admin-address http://localhost:8001 \
    manage \
    --port 7801 \
    --relay http://localhost:7900 \
    file quilkin.yaml
</code></pre>
<p>Now if we run cURL on both the relay and the control plane we should see that
they both contain the same set of endpoints.</p>
<pre><code class="language-bash"># Check Control Plane
curl localhost:8001/config
# Check Relay
curl localhost:8000/config
</code></pre>
<p>Since the relay service also exposes a aDS control plane endpoint, that
represents the merged set of all sources, to connect this to the proxy all we
have to do is use the same <code>--management-server</code> flag that we use to specify
the location of control planes, then the proxies will be able to pull
configuration from the relay.</p>
<pre><code>quilkin --admin-address http://localhost:8002 proxy --management-server http://127.0.0.1:7800
</code></pre>
<p>We can also additionally add a second control plane source to the relay, which
will be merged with our control plane's configuration to create a singular
set of data that the proxies can query using xDS discovery requests.</p>
<pre><code class="language-yaml"># quilkin2.yaml
version: v1alpha1
clusters:
  - endpoints:
    - address: 127.0.0.1:9999
</code></pre>
<pre><code>quilkin --admin-address http://localhost:8003 \
    manage \
    --port 7802 \
    --relay http://localhost:7900 \
    file quilkin.yaml
</code></pre>
<p>And that's it! We've just setup control planes to look for configuration changes
in our system, a relay to merge any changes into a unified dataset, and set up
proxies that make use of that data to decide where and how to send packets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quilkin-agent"><a class="header" href="#quilkin-agent">Quilkin Agent</a></h1>
<div class="table-wrapper"><table><thead><tr><th>services</th><th>ports</th><th>Protocol</th></tr></thead><tbody>
<tr><td>QCMP</td><td>7600</td><td>UDP(IPv4 OR IPv6)</td></tr>
</tbody></table>
</div>
<p>For multi-cluster integration, Quilkin provides a <code>agent</code> service, that can be
deployed to a cluster to act as a beacon for QCMP pings and forward cluster
configuration information to a <code>relay</code> service.</p>
<p>Agent configuration sources matches that of the <a href="services/./xds.html">Management Server</a>, such as
<a href="services/./xds/providers/filesystem.html">Filesystem</a> and <a href="services/./xds/providers/agones.html">Agones</a>.</p>
<p>To view all options for the <code>agent</code> subcommand, run:</p>
<pre><code class="language-shell">$ quilkin agent --help
Runs Quilkin as a relay service that runs a Manager Discovery Service (mDS) for accepting cluster and configuration information from xDS management services, and exposing it as a single merged xDS service for proxy services

Usage: quilkin agent [OPTIONS] [COMMAND]

Commands:
  agones  Watches Agones' game server CRDs for `Allocated` game server endpoints, and for a `ConfigMap` that specifies the filter configuration
  file    Watches for changes to the file located at `path`
  help    Print this message or the help of the given subcommand(s)

Options:
  -q, --qcmp-port &lt;QCMP_PORT&gt;        Port for QCMP service [env: QCMP_PORT=] [default: 7600]
  -r, --relay &lt;RELAY&gt;                One or more `quilkin relay` endpoints to push configuration changes to [env: QUILKIN_MANAGEMENT_SERVER=]
      --region &lt;REGION&gt;              The `region` to set in the cluster map for any provider endpoints discovered [env: QUILKIN_REGION=]
      --zone &lt;ZONE&gt;                  The `zone` in the `region` to set in the cluster map for any provider endpoints discovered [env: QUILKIN_ZONE=]
      --sub-zone &lt;SUB_ZONE&gt;          The `sub_zone` in the `zone` in the `region` to set in the cluster map for any provider endpoints discovered [env: QUILKIN_SUB_ZONE=]
      --address-type &lt;ADDRESS_TYPE&gt;  If specified, filters the available gameserver addresses to the one that matches the specified type
      --ip-kind &lt;IP_KIND&gt;            If specified, additionally filters the gameserver address by its ip kind [possible values: v4, v6, any]
  -i, --icao-code &lt;ICAO_CODE&gt;        The ICAO code for the agent [env: ICAO_CODE=] [default: XXXX]
  -h, --help                         Print help
</code></pre>
<h2 id="quickstart-1"><a class="header" href="#quickstart-1">Quickstart</a></h2>
<p>The simplest version of the <code>agent</code> service is just running <code>quilkin agent</code>,
this will setup just the QCMP service allowing the agent to be pinged for
measuring round-time-trips (RTT).</p>
<pre><code>quilkin agent
</code></pre>
<p>To run an agent with the relay (see <a href="services/./relay.html#quickstart"><code>relay</code> quickstart</a>
for more information), you just need to specify the relay endpoint with the
<code>--relay</code> flag <strong>and</strong> provide a configuration discovery provider such as a
configuration file or Agones.</p>
<pre><code>quilkin --admin-adress http://localhost:8001 agent --relay http://localhost:7900 file quilkin.yaml
</code></pre>
<p>Now if we run cURL on both the relay and the control plane we should see that
they both contain the same set of endpoints.</p>
<pre><code class="language-bash"># Check Agent
curl localhost:8001/config
# Check Relay
curl localhost:8000/config
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quilkin-unreal-engine-plugin"><a class="header" href="#quilkin-unreal-engine-plugin">Quilkin Unreal Engine Plugin</a></h1>
<p>This is an unreal engine 5 plugin for Quilkin, a UDP proxy for gameservers. The plugin provides several features that you can use with Quilkin deployments, such as proxying game traffic, and latency measurement.</p>
<p>You can also find guide level documentation on how the proxy works in the <a href="https://googleforgames.github.io/quilkin/main/book/">Quilkin Book</a>.</p>
<h3 id="installation-1"><a class="header" href="#installation-1">Installation</a></h3>
<p>Copy this plugin to your <code>Plugins</code> folder in your <code>Engine</code> directory.</p>
<h3 id="configuration-3"><a class="header" href="#configuration-3">Configuration</a></h3>
<p>Static configuration is available in the editor through <code>UQuilkinDeveloperSettings</code> in "Project Settings".</p>
<p>Dynamic configuration is available through <code>UQuilkinConfigSubsystem</code>, it is initialised from the settings provided in <code>UQuilkinDeveloperSettings</code>, but can also be updated in code, and users can bind individual properties to delegates allowing them to dynamically set based on custom logic.</p>
<ul>
<li><code>bool Enabled</code> Whether the plugin will attach a versioned routing token to UDP packets to allow load balancers forward traffic to the correct gameserver. This also requires the address the clients connect to be a Quilkin load balancer, if connected directly to a gameserver the client will be rejected.</li>
<li><code>bool EnabledInPie</code> By default <code>Enabled</code> is disabled in editor to prevent interfering with local clients and gameservers, you can override this behaviour by also enabling <code>EnabledInPie</code>.</li>
<li><code>TArray&lt;uint8&gt; RoutingToken</code> The routing token representing the gameserver a client wants to reach, the token <strong>must</strong> be 16 bytes exactly. Currently the plugin only supports using <code>Enabled</code> with a routing token to create the following layout. It is assumed that the routing token would come from an external service, such as a matchmaking system.</li>
</ul>
<pre><code>&lt;packet&gt; | token    | version
 X bytes | 16 bytes | 1 byte
</code></pre>
<ul>
<li><code>TArray&lt;FQuilkinEndpoint&gt; Endpoints</code> A set of Quilkin load balancer endpoints that can be used for the following features.</li>
<li><code>bool MeasureEndpoints</code> When enabled, the plugin will start a new <code>Tick</code> task that executes at a fixed interval (currently 30 seconds), where it will spawn a new background task that will ping each endpoint in <code>Endpoints</code>, and track its measurement in a fixed size circular buffer.
Pings are handled through Quilkin Control Message Protocol, this is a bespoke protocol for UDP to be able to support situations where for example using ICMP is not possible, see the <a href="https://googleforgames.github.io/quilkin/main/book/services/proxy/qcmp.html">Quilkin Book</a> for more details on the protocol data unit.
<strong>Note</strong> <code>MeasureEndpoints</code> is orthogonal to <code>Enabled</code> and <code>UseEndpoints</code> meaning that you can use <code>MeasureEndpoints</code> for latency measurements without being required to also use Quilkin for game traffic.</li>
<li><code>bool UseEndpoints</code> Whether to use <code>Endpoints</code> for game traffic. When enabled, instead of using the provided <code>FInternetAddr</code>, the plugin will choose the lowest latency endpoint available and send traffic through that endpoint to connect to the gameserver, and if the latency should exceed <code>JitterThreshold</code> then the plugin will attempt to redirect traffic to the next available endpoint with the lowest latency.</li>
</ul>
<h3 id="delegates"><a class="header" href="#delegates">Delegates</a></h3>
<p>Quilkin exposes a number of delegates to be able to access certain information, they can be accessed through the <code>FQuilkinDelegates</code> class.</p>
<ul>
<li>
<p><code>GetQuilkinEndpointMeasurements</code> returns <code>TArray&lt;EndpointPair&gt;</code> representing each endpoint set in <code>Endpoints</code> with their median latency. The array will be empty if no endpoints have been set and <code>MeasureEndpoints</code> is not enabled.</p>
</li>
<li>
<p><code>GetLowestLatencyEndpoint</code> returns <code>TOptional&lt;EndpointPair&gt;</code> is a specialisation of <code>GetQuilkinEndpointMeasurements</code> returning the lowest latency endpoint and its median latency. The delegate will return <code>None</code> if the array is empty and <code>MeasureEndpoints</code> is not enabled.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="administration"><a class="header" href="#administration">Administration</a></h1>
<div class="table-wrapper"><table><thead><tr><th>services</th><th>ports</th><th>Protocol</th></tr></thead><tbody>
<tr><td>Administration</td><td>8000</td><td>HTTP (IPv4 OR IPv6)</td></tr>
</tbody></table>
</div>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<p>By default, Quilkin will log <code>INFO</code> level events, you can change this by setting
the <code>RUST_LOG</code> environment variable. See <a href="https://docs.rs/env_logger/latest/env_logger/#enabling-logging"><code>log</code> documentation</a> for
more advanced usage.</p>
<blockquote>
<p>If you are debugging Quilkin set the <code>RUST_LOG</code> environment variable to <code>quilkin=trace</code>, to filter trace level
logging to only Quilkin components.</p>
</blockquote>
<blockquote>
<p>Verbose logging in Quilkin will affect performance considerably, so we recommend only
turning it on for debugging purposes.</p>
</blockquote>
<h2 id="http-api"><a class="header" href="#http-api">HTTP API</a></h2>
<p>Quilkin exposes an HTTP interface to query different aspects of the server.</p>
<blockquote>
<p>It is assumed that the administration interface will only ever be able to be accessible on <code>localhost</code>.</p>
</blockquote>
<p>By default, the administration interface is bound to <code>[::]:8000</code>, but it can be
configured with the <code>--admin-address</code> CLI flag or the <code>QUILKIN_ADMIN_ADDRESS</code>
environment.</p>
<h2 id="endpoints-1"><a class="header" href="#endpoints-1">Endpoints</a></h2>
<p>The admin interface provides the following endpoints:</p>
<h3 id="live"><a class="header" href="#live">/live</a></h3>
<p>This provides a liveness probe endpoint, most commonly used in
<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-a-liveness-command">Kubernetes based systems</a>.</p>
<p>Liveness is defined as "hasn't panicked", as long as the process has not
panicked quilkin is considered live.</p>
<h3 id="ready"><a class="header" href="#ready">/ready</a></h3>
<p>This provides a readiness probe endpoint, most commonly used in
<a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-readiness-probes">Kubernetes based systems</a>.</p>
<p>Readiness is service and provider specific, so based on what you're running
there will be different criteria for a service to be considered ready. Here's
a list of the criteria for each service an provider.</p>
<div class="table-wrapper"><table><thead><tr><th>Service</th><th>Readiness</th></tr></thead><tbody>
<tr><td>Proxy</td><td>Management server is connected (or always true if config is static)  OR if there is more than one endpoint configured</td></tr>
<tr><td>Manage</td><td>Provider is ready</td></tr>
<tr><td>Relay</td><td>Provider is ready</td></tr>
<tr><td>Agent</td><td>Provider is ready AND connected to relay</td></tr>
</tbody></table>
</div><br/>
<div class="table-wrapper"><table><thead><tr><th>Provider</th><th>Readiness</th></tr></thead><tbody>
<tr><td>Agones</td><td>The service is connected to kube-api</td></tr>
<tr><td>File</td><td>The service has found and watches the file</td></tr>
</tbody></table>
</div>
<p>When setting thresholds for your <code>proxy</code> probes, you generally want to set a low
check period (e.g.  <code>periodSeconds=1</code>) and a low success threshold
(e.g. <code>successThreshold=1</code>), but a high <code>failureThreshold</code>
(e.g. <code>failureThreshold=60</code>) and <code>terminationGracePeriodSeconds</code> to allow for
backoff attempts and existing player sessions to continue without disruption.</p>
<h4 id="proxy-mode-1"><a class="header" href="#proxy-mode-1">Proxy Mode</a></h4>
<p>Will return an HTTP status of 200 when there is at least one endpoint to send data to. This is primarily to ensure
that new proxies that have yet to get configuration information from an <a href="deployment/../services/xds.html">xDS server</a> aren't send data
until they are fully populated.</p>
<h4 id="xds-provider-mode-1"><a class="header" href="#xds-provider-mode-1">xDS Provider Mode</a></h4>
<p>Will return an HTTP status of 200 when all health checks pass.</p>
<h3 id="metrics-4"><a class="header" href="#metrics-4">/metrics</a></h3>
<p>Outputs <a href="https://prometheus.io/">Prometheus</a> formatted metrics for this instance.</p>
<p>See the <a href="deployment/../services/proxy/metrics.html">Proxy Metrics</a> documentation for what proxy metrics are available.</p>
<p>See the <a href="deployment/../services/xds/metrics.html">xDS Metrics</a> documentation for what xDS metrics are available.</p>
<h3 id="debugpprofprofile"><a class="header" href="#debugpprofprofile">/debug/pprof/profile</a></h3>
<p>This provides a endpoint to profile Quilkin's performance. You can use with any
system which supports pprof output such as <a href="https://pyroscope.io">Pyroscope</a>.</p>
<p>This requires setting up a writable <code>/tmp</code> directory in the Quilkin container. E.g.</p>
<pre><code class="language-yaml">apiVersion: apps/v1
kind: Deployment
spec:
  template:
    spec:
      containers:
        - name: quilkin
        # ...Other container configuration...
          volumeMounts:
            - mountPath: /tmp
              name: tmp
              subPath: tmp
      volumes:
        - name: tmp
          emptyDir:
            medium: Memory
            sizeLimit: 64Mi
</code></pre>
<h3 id="config"><a class="header" href="#config">/config</a></h3>
<p>Returns a JSON representation of the cluster and filterchain configuration that the instance is running
with at the time of invocation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quilkin-integration-examples"><a class="header" href="#quilkin-integration-examples">Quilkin Integration Examples</a></h1>
<p>The Quilkin proxy can be integrated with your dedicated game servers in several ways,
each providing different capabilities and complexity tradeoffs.</p>
<p>Below captures several of the most useful and prevalent architectural patterns to give you inspiration
on how you can use Quilkin in your multiplayer game networking architecture.</p>
<p>These <a href="https://github.com/googleforgames/quilkin/tree/main/examples">examples</a>
as well many others are available on Github repository.</p>
<h2 id="server-proxy-as-a-sidecar"><a class="header" href="#server-proxy-as-a-sidecar"><a href="https://github.com/googleforgames/quilkin/tree/main/examples/agones-xonotic-sidecar">Server Proxy as a Sidecar</a></a></h2>
<pre><code class="language-text">                  |
                  |
               Internet
                  |
                  |
                  |
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê       |          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Game   ‚îÇ       |          ‚îÇ Quilkin        ‚îÇ ‚îÇ Dedicated      ‚îÇ
‚îÇ  Client ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ (Server Proxy) ‚îÇ ‚îÇ Game Server    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò       |          ‚îÇ                ‚óÑ‚îÄ‚ñ∫                ‚îÇ
                  |          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  |
                  |
                  |          ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                  |          ‚îÇ Quilkin        ‚îÇ ‚îÇ Dedicated      ‚îÇ
                  |          ‚îÇ (Server Proxy) ‚îÇ ‚îÇ Game Server    ‚îÇ
                  |          ‚îÇ                ‚óÑ‚îÄ‚ñ∫                ‚îÇ
                  |          ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                  |
                  |
                  |
                  |
</code></pre>
<p>This is the simplest integration and configuration option with Quilkin, but does provide the smallest number
of possible feature implementations and ability to provide redundancy.</p>
<p>That being said, this is a low risk way to integrate Quilkin, and take advantage of the out-of-the-box telemetry
and metric information that comes with Quilkin.</p>
<ul>
<li>In this example, the Server proxy is running alongside the dedicated game server - on the same public IP/machine/container.
<ul>
<li>This is often referred to as a sidecar pattern.</li>
</ul>
</li>
<li>Communication between the Server Proxy and the Dedicated Game Server occurs over the localhost network, with a
separate port for each Game Client connection.</li>
<li>Clients connect to the Server Proxy's public port/IP combination, and the Server Proxy routes all traffic directly
to the dedicated game server.</li>
<li>The Server Proxy can still use filters such as rate limiting, compression, firewall rules, etc
as long as the Game Client conforms to the standard protocols utilised by those filters as appropriate.</li>
</ul>
<h2 id="client-proxy-to-sidecar-server-proxy"><a class="header" href="#client-proxy-to-sidecar-server-proxy">Client Proxy to Sidecar Server Proxy</a></h2>
<pre><code class="language-text">                                    |
                                    |
                                 Internet
                                    |
                                    |
                                    |
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   |        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Game   ‚îÇ    ‚îÇ Quilkin        ‚îÇ   |        ‚îÇ Quilkin        ‚îÇ ‚îÇ Dedicated      ‚îÇ
‚îÇ  Client ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ (Client Proxy) ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ (Server Proxy) ‚îÇ ‚îÇ Game Server    ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   |        ‚îÇ                ‚óÑ‚îÄ‚ñ∫                ‚îÇ
                                    |        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    |
                                    |
                                    |        ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                    |        ‚îÇ Quilkin        ‚îÇ ‚îÇ Dedicated      ‚îÇ
                                    |        ‚îÇ (Server Proxy) ‚îÇ ‚îÇ Game Server    ‚îÇ
                                    |        ‚îÇ                ‚óÑ‚îÄ‚ñ∫                ‚îÇ
                                    |        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    |
                                    |
                                    |
                                    |
</code></pre>
<p>This example is the same as the above, but puts a Client Proxy between the Game Client, and the Server Proxy to take
advantage of Client Proxy functionality.</p>
<ul>
<li>The Client Proxy may be integrated as a standalone binary, directly into the client with communication
occurring over a localhost port or it may be possible utlise one of our client SDKs such as <a href="deployment/../sdks/unreal-engine.html">Unreal Engine</a>.</li>
<li>The Client Proxy can now utilise filters, such as compression, without having to change the Game Client.</li>
<li>The Game Client will need to communicate to the Client Proxy what IP it should connect to when the Client is
match-made with a Game Server.</li>
</ul>
<h2 id="client-proxy-to-separate-server-proxies-pools"><a class="header" href="#client-proxy-to-separate-server-proxies-pools"><a href="https://github.com/googleforgames/quilkin/tree/main/examples/agones-xonotic-xds">Client Proxy to Separate Server Proxies Pools</a></a></h2>
<pre><code class="language-text">                                       |                             |
                                       |                             |
                                    Internet                      Private
                                       |                          Network
                                       |     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      |       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                       |     ‚îÇ Quilkin        ‚îÇ      |       ‚îÇ Dedicated      ‚îÇ
                                       |  ‚îå‚îÄ‚îÄ‚ñ∫ (Server Proxy) ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚ñ∫ Game Server    ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    |  ‚îÇ  ‚îÇ                ‚îÇ      |   ‚îÇ   ‚îÇ                ‚îÇ
‚îÇ  Game   ‚îÇ      ‚îÇ Quilkin        ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      |   ‚îÇ   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
‚îÇ  Client ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñ∫ (Client Proxy) ‚îÇ    |  ‚îÇ                          |   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    |  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      |   ‚îÇ   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                       |  ‚îÇ  ‚îÇ Quilkin        ‚îÇ      |   ‚îÇ   ‚îÇ Dedicated      ‚îÇ
                                       |  ‚îî‚îÄ‚îÄ‚ñ∫ (Server Proxy) ‚óÑ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ Game Server    ‚îÇ
                                       |     ‚îÇ                ‚îÇ      |       ‚îÇ                ‚îÇ
                                       |     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      |       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                       |                             |
                                       |     ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      |       ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                       |     ‚îÇ Quilkin        ‚îÇ      |       ‚îÇ Dedicated      ‚îÇ
                                       |     ‚îÇ (Server Proxy) ‚îÇ      |       ‚îÇ Game Server    ‚îÇ
                                       |     ‚îÇ                ‚îÇ      |       ‚îÇ                ‚îÇ
                                       |     ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      |       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                       |                 ‚ñ≤           |              ‚ñ≤
                                                         ‚îÇ                          ‚îÇ
                                                         ‚îÇ              ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îê
                                                         ‚îÇ              ‚îÇ xDS            ‚îÇ
                                                         ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§ Control Plane  ‚îÇ
                                                                        ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò




</code></pre>
<p>This is the most complex configuration, but enables the most reuse of Quilkin's functionality,
while also providing the most redundancy and security for your dedicated game servers.</p>
<ul>
<li>The Game client sends and receives packets from the Quilkin client proxy.</li>
<li>The Client Proxy may be integrated as a standalone binary, with communication occurring over a localhost port, or
it could be integrated directly with the game client as a library, or the client could utilise one of our
[client SDKs] if Rust integration is not possible.</li>
<li>The Client Proxy can utilise the full set of filters, such as concatenation (for routing), compression or load
balancing, without having to change the Game Client.</li>
<li>A hosted set of Quilkin Server proxies that have public IP addresses, are connected to an
<a href="deployment/../services/xds.html">xDS Control Plane</a> to coordinate routing and access control to the dedicated game servers, which are
on private IP addresses.</li>
<li>The Client Proxy is made aware of one or more Server proxies to connect to, possibly via their Game Client matchmaker
or another service, with an authentication token to pass to the Server proxies, such that the UDP packets can be
routed correctly to the dedicated game server they should connect to.</li>
<li>Dedicated game servers receive traffic as per normal from the Server Proxies, and send data back to the proxies
directly.</li>
<li>If the dedicated game server always expects traffic from only a single ip/port combination for client connection,
then traffic will always need to be sent through a single Server Proxy. Otherwise, UDP packets can be load
balanced via the Client Proxy to multiple Server Proxies for even greater redundancy.</li>
</ul>
<h2 id="what-next-1"><a class="header" href="#what-next-1">What Next?</a></h2>
<ul>
<li>Have a look at the <a href="deployment/./admin.html">Administration API</a>.</li>
<li>Review the <a href="deployment/../services/proxy/filters.html">set of filters</a> that are available.</li>
</ul>
<hr />
<p>Diagrams powered by <a href="http://asciiflow.com/" target="_blank">asciiflow.com</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="third-party-videos-and-presentations"><a class="header" href="#third-party-videos-and-presentations">Third Party Videos and Presentations</a></h1>
<h2 id="gdc-2023-open-source-game-development-summit-agones-and-quilkin-oss-multiplayer-game-server-service-mesh-on-kubernetes"><a class="header" href="#gdc-2023-open-source-game-development-summit-agones-and-quilkin-oss-multiplayer-game-server-service-mesh-on-kubernetes">GDC 2023: Open Source Game Development Summit: Agones and Quilkin: OSS Multiplayer Game Server Service Mesh on Kubernetes</a></h2>
<a href="https://www.gdcvault.com/play/1029264/Open-Source-Game-Development-Summit" target="_blank">
<img src="third-party/./vault.png" alt="Presentation recording" />
</a>
<p>(Does not require GDCVault access to watch)</p>
<p>Previous talks have looked at two open source projects: Agones, the platform for orchestrating and scaling
dedicated multiplayer game servers on top of Kubernetes, and Quilkin, an extensible UDP proxy specifically built
for protecting, observing and authenticating game server communications.</p>
<p>On the surface this seems like a very powerful combination, but manually integrating the two can be a tricky and
intimidating process. You need to know and understand the Kubernetes API and its client libraries, and then tie it
into Quilkin's xDS compliant API implementation all through some custom code - which is a large and complex amount
of work (and a lot of acronyms).</p>
<p>In this talk, Mark Mandel, Developer Advocate at Google Cloud, will look at how anyone can utilize Quilkin's native
Agones integration to provide a turnkey solution for proxying UDP traffic to game servers providing an extra layer
of protection and observability when orchestrating game servers on top of Kubernetes.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
